a:1:{s:22:"PHPCodePrintingHandler";a:1:{s:7:"methods";a:52:{s:23:"getPHPClassesFromFolder";a:20:{s:4:"name";s:23:"getPHPClassesFromFolder";s:16:"start_line_index";i:15;s:17:"start_token_index";i:21;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:20:"/* START: GETTERS */";}s:25:"start_comments_line_index";i:14;s:26:"start_comments_token_index";i:19;s:23:"end_comments_line_index";i:14;s:24:"end_comments_token_index";i:19;s:22:"start_args_token_index";i:28;s:20:"end_args_token_index";i:30;s:9:"arguments";a:1:{s:12:"$folder_path";N;}s:25:"start_brackets_line_index";i:15;s:26:"start_brackets_token_index";i:32;s:23:"end_brackets_line_index";i:27;s:24:"end_brackets_token_index";i:123;s:14:"end_line_index";i:27;s:15:"end_token_index";i:123;}s:34:"getPHPClassesFromFolderRecursively";a:15:{s:4:"name";s:34:"getPHPClassesFromFolderRecursively";s:16:"start_line_index";i:29;s:17:"start_token_index";i:125;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:132;s:20:"end_args_token_index";i:134;s:9:"arguments";a:1:{s:12:"$folder_path";N;}s:25:"start_brackets_line_index";i:29;s:26:"start_brackets_token_index";i:136;s:23:"end_brackets_line_index";i:41;s:24:"end_brackets_token_index";i:227;s:14:"end_line_index";i:41;s:15:"end_token_index";i:227;}s:21:"getPHPClassesFromFile";a:15:{s:4:"name";s:21:"getPHPClassesFromFile";s:16:"start_line_index";i:43;s:17:"start_token_index";i:229;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:236;s:20:"end_args_token_index";i:238;s:9:"arguments";a:1:{s:10:"$file_path";N;}s:25:"start_brackets_line_index";i:43;s:26:"start_brackets_token_index";i:240;s:23:"end_brackets_line_index";i:49;s:24:"end_brackets_token_index";i:286;s:14:"end_line_index";i:49;s:15:"end_token_index";i:286;}s:23:"getPHPClassesFromString";a:20:{s:4:"name";s:23:"getPHPClassesFromString";s:16:"start_line_index";i:52;s:17:"start_token_index";i:290;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:43:"//http://es.php.net/manual/pt_BR/tokens.php";}s:25:"start_comments_line_index";i:51;s:26:"start_comments_token_index";i:288;s:23:"end_comments_line_index";i:51;s:24:"end_comments_token_index";i:288;s:22:"start_args_token_index";i:297;s:20:"end_args_token_index";i:299;s:9:"arguments";a:1:{s:9:"$php_code";N;}s:25:"start_brackets_line_index";i:52;s:26:"start_brackets_token_index";i:301;s:23:"end_brackets_line_index";i:55;s:24:"end_brackets_token_index";i:323;s:14:"end_line_index";i:55;s:15:"end_token_index";i:323;}s:23:"getPHPClassesFromTokens";a:15:{s:4:"name";s:23:"getPHPClassesFromTokens";s:16:"start_line_index";i:57;s:17:"start_token_index";i:325;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:332;s:20:"end_args_token_index";i:334;s:9:"arguments";a:1:{s:7:"$tokens";N;}s:25:"start_brackets_line_index";i:57;s:26:"start_brackets_token_index";i:336;s:23:"end_brackets_line_index";i:583;s:24:"end_brackets_token_index";i:5081;s:14:"end_line_index";i:583;s:15:"end_token_index";i:5081;}s:29:"prepareClassNameWithNameSpace";a:15:{s:4:"name";s:29:"prepareClassNameWithNameSpace";s:16:"start_line_index";i:585;s:17:"start_token_index";i:5083;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:5090;s:20:"end_args_token_index";i:5099;s:9:"arguments";a:2:{s:11:"$class_name";N;s:10:"$namespace";s:2:"""";}s:25:"start_brackets_line_index";i:585;s:26:"start_brackets_token_index";i:5101;s:23:"end_brackets_line_index";i:587;s:24:"end_brackets_token_index";i:5153;s:14:"end_line_index";i:587;s:15:"end_token_index";i:5153;}s:30:"decoupleClassNameWithNameSpace";a:15:{s:4:"name";s:30:"decoupleClassNameWithNameSpace";s:16:"start_line_index";i:589;s:17:"start_token_index";i:5155;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:5162;s:20:"end_args_token_index";i:5164;s:9:"arguments";a:1:{s:11:"$class_name";N;}s:25:"start_brackets_line_index";i:589;s:26:"start_brackets_token_index";i:5166;s:23:"end_brackets_line_index";i:600;s:24:"end_brackets_token_index";i:5274;s:14:"end_line_index";i:600;s:15:"end_token_index";i:5274;}s:16:"getClassFromFile";a:15:{s:4:"name";s:16:"getClassFromFile";s:16:"start_line_index";i:658;s:17:"start_token_index";i:5874;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:5881;s:20:"end_args_token_index";i:5886;s:9:"arguments";a:2:{s:10:"$file_path";N;s:11:"$class_name";N;}s:25:"start_brackets_line_index";i:658;s:26:"start_brackets_token_index";i:5888;s:23:"end_brackets_line_index";i:667;s:24:"end_brackets_token_index";i:5948;s:14:"end_line_index";i:667;s:15:"end_token_index";i:5948;}s:22:"getClassFromPHPClasses";a:15:{s:4:"name";s:22:"getClassFromPHPClasses";s:16:"start_line_index";i:669;s:17:"start_token_index";i:5950;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:5957;s:20:"end_args_token_index";i:5962;s:9:"arguments";a:2:{s:8:"$classes";N;s:11:"$class_name";N;}s:25:"start_brackets_line_index";i:669;s:26:"start_brackets_token_index";i:5964;s:23:"end_brackets_line_index";i:682;s:24:"end_brackets_token_index";i:6098;s:14:"end_line_index";i:682;s:15:"end_token_index";i:6098;}s:25:"searchClassFromPHPClasses";a:15:{s:4:"name";s:25:"searchClassFromPHPClasses";s:16:"start_line_index";i:684;s:17:"start_token_index";i:6100;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:6107;s:20:"end_args_token_index";i:6112;s:9:"arguments";a:2:{s:8:"$classes";N;s:11:"$class_name";N;}s:25:"start_brackets_line_index";i:684;s:26:"start_brackets_token_index";i:6114;s:23:"end_brackets_line_index";i:697;s:24:"end_brackets_token_index";i:6259;s:14:"end_line_index";i:697;s:15:"end_token_index";i:6259;}s:25:"getClassPathFromClassName";a:20:{s:4:"name";s:25:"getClassPathFromClassName";s:16:"start_line_index";i:700;s:17:"start_token_index";i:6263;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:134:"//checks if the $class_name really exists in file and if not checks for the correspondent with the namespace and return the class_path";}s:25:"start_comments_line_index";i:699;s:26:"start_comments_token_index";i:6261;s:23:"end_comments_line_index";i:699;s:24:"end_comments_token_index";i:6261;s:22:"start_args_token_index";i:6270;s:20:"end_args_token_index";i:6275;s:9:"arguments";a:2:{s:10:"$file_path";N;s:11:"$class_name";N;}s:25:"start_brackets_line_index";i:700;s:26:"start_brackets_token_index";i:6277;s:23:"end_brackets_line_index";i:716;s:24:"end_brackets_token_index";i:6390;s:14:"end_line_index";i:716;s:15:"end_token_index";i:6390;}s:14:"getClassOfFile";a:20:{s:4:"name";s:14:"getClassOfFile";s:16:"start_line_index";i:719;s:17:"start_token_index";i:6394;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:135:"//based in a file, get the correspondent class (basically based in the file name, get sthe correspondent class data inside of the file.";}s:25:"start_comments_line_index";i:718;s:26:"start_comments_token_index";i:6392;s:23:"end_comments_line_index";i:718;s:24:"end_comments_token_index";i:6392;s:22:"start_args_token_index";i:6401;s:20:"end_args_token_index";i:6403;s:9:"arguments";a:1:{s:10:"$file_path";N;}s:25:"start_brackets_line_index";i:719;s:26:"start_brackets_token_index";i:6405;s:23:"end_brackets_line_index";i:739;s:24:"end_brackets_token_index";i:6551;s:14:"end_line_index";i:739;s:15:"end_token_index";i:6551;}s:24:"getClassPropertyFromFile";a:15:{s:4:"name";s:24:"getClassPropertyFromFile";s:16:"start_line_index";i:741;s:17:"start_token_index";i:6553;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:6560;s:20:"end_args_token_index";i:6568;s:9:"arguments";a:3:{s:10:"$file_path";N;s:11:"$class_name";N;s:10:"$prop_name";N;}s:25:"start_brackets_line_index";i:741;s:26:"start_brackets_token_index";i:6570;s:23:"end_brackets_line_index";i:751;s:24:"end_brackets_token_index";i:6660;s:14:"end_line_index";i:751;s:15:"end_token_index";i:6660;}s:19:"getFunctionFromFile";a:15:{s:4:"name";s:19:"getFunctionFromFile";s:16:"start_line_index";i:753;s:17:"start_token_index";i:6662;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:6669;s:20:"end_args_token_index";i:6681;s:9:"arguments";a:3:{s:10:"$file_path";N;s:10:"$func_name";N;s:11:"$class_name";s:1:"0";}s:25:"start_brackets_line_index";i:753;s:26:"start_brackets_token_index";i:6683;s:23:"end_brackets_line_index";i:760;s:24:"end_brackets_token_index";i:6733;s:14:"end_line_index";i:760;s:15:"end_token_index";i:6733;}s:21:"getFunctionFromString";a:15:{s:4:"name";s:21:"getFunctionFromString";s:16:"start_line_index";i:762;s:17:"start_token_index";i:6735;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:6742;s:20:"end_args_token_index";i:6754;s:9:"arguments";a:3:{s:9:"$contents";N;s:10:"$func_name";N;s:11:"$class_name";s:1:"0";}s:25:"start_brackets_line_index";i:762;s:26:"start_brackets_token_index";i:6756;s:23:"end_brackets_line_index";i:785;s:24:"end_brackets_token_index";i:6995;s:14:"end_line_index";i:785;s:15:"end_token_index";i:6995;}s:21:"getNamespacesFromFile";a:15:{s:4:"name";s:21:"getNamespacesFromFile";s:16:"start_line_index";i:787;s:17:"start_token_index";i:6997;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:7004;s:20:"end_args_token_index";i:7006;s:9:"arguments";a:1:{s:10:"$file_path";N;}s:25:"start_brackets_line_index";i:787;s:26:"start_brackets_token_index";i:7008;s:23:"end_brackets_line_index";i:798;s:24:"end_brackets_token_index";i:7052;s:14:"end_line_index";i:798;s:15:"end_token_index";i:7052;}s:15:"getUsesFromFile";a:15:{s:4:"name";s:15:"getUsesFromFile";s:16:"start_line_index";i:800;s:17:"start_token_index";i:7054;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:7061;s:20:"end_args_token_index";i:7063;s:9:"arguments";a:1:{s:10:"$file_path";N;}s:25:"start_brackets_line_index";i:800;s:26:"start_brackets_token_index";i:7065;s:23:"end_brackets_line_index";i:811;s:24:"end_brackets_token_index";i:7109;s:14:"end_line_index";i:811;s:15:"end_token_index";i:7109;}s:19:"getIncludesFromFile";a:15:{s:4:"name";s:19:"getIncludesFromFile";s:16:"start_line_index";i:813;s:17:"start_token_index";i:7111;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:7118;s:20:"end_args_token_index";i:7120;s:9:"arguments";a:1:{s:10:"$file_path";N;}s:25:"start_brackets_line_index";i:813;s:26:"start_brackets_token_index";i:7122;s:23:"end_brackets_line_index";i:826;s:24:"end_brackets_token_index";i:7166;s:14:"end_line_index";i:826;s:15:"end_token_index";i:7166;}s:26:"getClassPropertiesFromFile";a:20:{s:4:"name";s:26:"getClassPropertiesFromFile";s:16:"start_line_index";i:909;s:17:"start_token_index";i:7560;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:1098:"/* This is DEPRECATED bc if php is obfuscated this doesn't work.
	private static function getCodeInstructionFromFile($file_path, $types) {
		$instructions = array();
		
		if ($file_path && file_exists($file_path) && $types) {
			$types = is_array($types) ? $types : array($types);
			
			$contents = file_get_contents($file_path);
			$contents = str_replace("\r\n", "\n", $contents);
			$lines = explode("\n", $contents);
			
			$t = count($lines);
			for ($i = 0; $i < $t; $i++) {
				$line = $lines[$i];
				$trimmed = trim($line);
				
				foreach ($types as $type)
					if ($type) {
						$pos = stripos($trimmed, $type);
						
						//checks instruction at the begginning of the line
						if ($pos === 0) {
							$start_pos = $pos + strlen($type);
							$end_pos = strpos($trimmed, ";", $start_pos);
							$end_pos = $end_pos !== false ? $end_pos : strlen($end_pos);
							
							$instruction = trim( substr($trimmed, $start_pos, $end_pos - $start_pos) );
							$instructions[] = array($instruction, $type);
							
							break;
						}
					}
			}
		}
		
		return $instructions;
	}*/";}s:25:"start_comments_line_index";i:871;s:26:"start_comments_token_index";i:7558;s:23:"end_comments_line_index";i:871;s:24:"end_comments_token_index";i:7558;s:22:"start_args_token_index";i:7567;s:20:"end_args_token_index";i:7572;s:9:"arguments";a:2:{s:10:"$file_path";N;s:11:"$class_name";N;}s:25:"start_brackets_line_index";i:909;s:26:"start_brackets_token_index";i:7574;s:23:"end_brackets_line_index";i:916;s:24:"end_brackets_token_index";i:7623;s:14:"end_line_index";i:916;s:15:"end_token_index";i:7623;}s:28:"getClassPropertiesFromString";a:15:{s:4:"name";s:28:"getClassPropertiesFromString";s:16:"start_line_index";i:918;s:17:"start_token_index";i:7625;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:7632;s:20:"end_args_token_index";i:7637;s:9:"arguments";a:2:{s:9:"$contents";N;s:11:"$class_name";N;}s:25:"start_brackets_line_index";i:918;s:26:"start_brackets_token_index";i:7639;s:23:"end_brackets_line_index";i:1061;s:24:"end_brackets_token_index";i:9126;s:14:"end_line_index";i:1061;s:15:"end_token_index";i:9126;}s:23:"getFunctionCodeFromFile";a:20:{s:4:"name";s:23:"getFunctionCodeFromFile";s:16:"start_line_index";i:1262;s:17:"start_token_index";i:9130;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:7781:"/* This is DEPRECATED bc if php is obfuscated this doesn't work. Besides it doesn't get the values correctly if they have comments at the first line of the properties value
	public static function getClassPropertiesFromFile($file_path, $class_name) {
		$properties = array();
		
		if ($file_path && file_exists($file_path) && $class_name) {
			$contents = file_get_contents($file_path);
			
			$classes = self::getPHPClassesFromString($contents);
			$c = self::getClassFromPHPClasses($classes, $class_name);
			$class_name = $c["name"];
			$start_brackets_line = $c["start_brackets_line_index"];
			
			if (is_numeric($start_brackets_line)) {
				$contents = str_replace("\r\n", "\n", $contents);
				$lines = explode("\n", $contents);
				
				//GETTING PROPERTIES IN TEXT
				$line = $lines[ $start_brackets_line - 1 ];
				$pos = strpos($line, "{");
				$pos = $pos !== false ? $pos : strlen($line);
				
				$intervals = array();
				$t = $c["methods"] ? count($c["methods"]) : 0;
				for ($i = 0; $i < $t; $i++) {
					$sli = is_numeric($c["methods"][$i]["start_comments_line_index"]) ? $c["methods"][$i]["start_comments_line_index"] : $c["methods"][$i]["start_line_index"];
					$intervals[] = array($sli, $c["methods"][$i]["end_line_index"]);
				}
				
				$new_c = substr($line, $pos + 1);
				$idx = $start_brackets_line - 1;
				while (true) {
					++$idx;
					
					if ($idx + 1 >= $c["end_line_index"])
						break;
					
					$allowed = true;
					foreach ($intervals as $interval)
						if ($idx + 1 >= $interval[0] && $idx + 1 <= $interval[1]) {
							$allowed = false;
							break;
						}
					
					if ($allowed && trim($lines[$idx])) 
						$new_c .= "\n" . $lines[$idx];
				}
				$new_c = trim($new_c);
				
				//PARSEING PROPERTIES
				$t = strlen($new_c);
				$open_single_quotes = $open_double_quotes = $open_multiple_comments = $open_single_comments = false;
				$prop_doc_comments = $prop_comments = array();
				
				for ($i = 0; $i < $t; $i++) {
					$char = $new_c[$i];
					
					if (!$open_single_quotes && !$open_double_quotes && !$open_multiple_comments && !$open_single_comments && ($char == '$' ||
						(strtolower($char) == "c" && strtolower($new_c[$i+1]) == "o" && strtolower($new_c[$i+2]) == "n" && strtolower($new_c[$i+3]) == "s" && strtolower($new_c[$i+4]) == "t")
					)) {
						$idx = $char == '$' ? $i : $i + 5;
						
						$settings = "";
						for ($j = $idx - 1; $j >= 0; --$j) {
							$char = $new_c[$j];
							
							if ($char == ";" || $char == "{" || $char == "}" || $char == "\n")
								break;
							else if ($char != "\t") 
								$settings = $char . $settings;
						}
						
						$var_name = "";
						for ($j = $idx + 1; $j < $t; $j++) {
							$char = $new_c[$j];
							
							if ($char == " " || $char == "=" || $char == "\t" || $char == "\n" || $char == ";")
								break;
							else 
								$var_name .= $char;
						}
						
						$value = "";
						$start_value = false;
						for ($j = $j - 1; $j < $t; $j++) {
							$char = $new_c[$j];
							
							if ($start_value) {
								$value .= $char;
								
								if ($char == "'" && !$open_double_quotes && !$open_multiple_comments && !$open_single_comments && !TextSanitizer::isCharEscaped($new_c, $j)) 
									$open_single_quotes = !$open_single_quotes;
								else if ($char == '"' && !$open_single_quotes && !$open_multiple_comments && !$open_single_comments && !TextSanitizer::isCharEscaped($new_c, $j)) 
									$open_double_quotes = !$open_double_quotes;
								else if ($char == '/' && $new_c[$j + 1] == "*" && !$open_single_quotes && !$open_double_quotes && !$open_single_comments) {
									$open_multiple_comments = true;
									++$j;
								}
								else if ($open_multiple_comments && $char == '*' && $new_c[$j + 1] == "/") {
									$open_multiple_comments = false;
									++$j;
								}
								else if ($char == '/' && $new_c[$j + 1] == "/" && !$open_single_quotes && !$open_double_quotes && !$open_multiple_comments) {
									$open_single_comments = true;
									++$j;
								}
								else if ($open_single_comments && $char == "\n")
									$open_single_comments = false;
							}
							
							if (!$open_single_quotes && !$open_double_quotes && !$open_multiple_comments && !$open_single_comments) {
								if ($char == ";") {
									if ($j == $i + 1)
										$value = null;
									else
										$value = substr($value, 0, strlen($value) - 1);//remove ;
									
									break;
								}
								else if (!$start_value && $char == "=")
									$start_value = true;
							}
						}
						$value = $value ? trim($value) : $value;
						
						$i = $j;
						
						$settings = trim(strtolower($settings));
						$type = strpos($settings, "private") !== false ? "private" : (strpos($settings, "protected") !== false ? "protected" : "public");
						
						$quote_char = substr($value, 0, 1);
						$var_type = $value && ($quote_char == '"' || $quote_char == "'") ? "string" : "";
						
						if ($quote_char == '"' || $quote_char == "'") {
							$value = substr($value, 1);
							$value = substr($value, -1) == $quote_char ? substr($value, 0, -1) : $value;
							$value = $quote_char == '"' ? str_replace('\\"', '"', $value) : str_replace("\\'", "'", $value);//in case of slashes and \" or \' accorddingly. Do not add the addcslashes here. We only want to add the \\" and \\', because we are getting php code directly.
							
							if ($quote_char == "'")
								$value = str_replace('$', '\\$', $value);//$variables inside of single quotes are escaped because are simply strings and not variables.
						}
						
						//check inline comments
						$pos = strpos($new_c, "\n", $i);
						$pos = $pos !== false ? $pos : $t;
						$aux = trim(substr($new_c, $i + 1, $pos - $i));
						
						if ($aux && substr($aux, 0, 2) == "//") {
							$prop_comments[] = $aux;
							$i = $pos;
						}
						
						$properties[] = array(
							"name" => $var_name,
							"type" => $type,
							"value" => $value,
							"var_type" => $var_type,
							"static" => strpos($settings, "static") !== false,
							"const" => strpos($settings, "const") !== false,
							"doc_comments" => $prop_doc_comments ? $prop_doc_comments : null,
							"comments" => $prop_comments ? $prop_comments : null,
						);
						
						$prop_doc_comments = $prop_comments = array();
					}
					else if ($char == "'" && !$open_double_quotes && !$open_multiple_comments && !$open_single_comments && !TextSanitizer::isCharEscaped($new_c, $i)) {
						$open_single_quotes = !$open_single_quotes;
					}
					else if ($char == '"' && !$open_single_quotes && !$open_multiple_comments && !$open_single_comments && !TextSanitizer::isCharEscaped($new_c, $i)) {
						$open_double_quotes = !$open_double_quotes;
					}
					else if ($char == '/' && $new_c[$i + 1] == "*" && !$open_single_quotes && !$open_double_quotes && !$open_single_comments) {
						$pos = strpos($new_c, "*" . "/", $i); //"*" . "/" is bc this method code is commented!
						$pos = $pos !== false ? $pos + 1 : $t;
						$prop_doc_comments[] = substr($new_c, $i, $pos - $i + 1);
						
						$open_multiple_comments = true;
						++$i;
					}
					else if ($open_multiple_comments && $char == '*' && $new_c[$i + 1] == "/") {
						$open_multiple_comments = false;
						++$i;
					}
					else if ($char == '/' && $new_c[$i + 1] == "/" && !$open_single_quotes && !$open_double_quotes && !$open_multiple_comments) {
						$pos = strpos($new_c, "\n", $i);
						$pos = $pos !== false ? $pos : $t;
						$prop_comments[] = substr($new_c, $i, $pos - $i);
						
						$open_single_comments = true;
						++$i;
					}
					else if ($open_single_comments && $char == "\n") {
						$open_single_comments = false;
					}
				}
			}
		}
		
		return $properties;
	}*/";}s:25:"start_comments_line_index";i:1062;s:26:"start_comments_token_index";i:9128;s:23:"end_comments_line_index";i:1062;s:24:"end_comments_token_index";i:9128;s:22:"start_args_token_index";i:9137;s:20:"end_args_token_index";i:9156;s:9:"arguments";a:4:{s:10:"$file_path";N;s:10:"$func_name";N;s:11:"$class_name";s:1:"0";s:4:"$raw";s:5:"false";}s:25:"start_brackets_line_index";i:1262;s:26:"start_brackets_token_index";i:9158;s:23:"end_brackets_line_index";i:1269;s:24:"end_brackets_token_index";i:9211;s:14:"end_line_index";i:1269;s:15:"end_token_index";i:9211;}s:25:"getFunctionCodeFromString";a:15:{s:4:"name";s:25:"getFunctionCodeFromString";s:16:"start_line_index";i:1271;s:17:"start_token_index";i:9213;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:9220;s:20:"end_args_token_index";i:9239;s:9:"arguments";a:4:{s:9:"$contents";N;s:10:"$func_name";N;s:11:"$class_name";s:1:"0";s:4:"$raw";s:5:"false";}s:25:"start_brackets_line_index";i:1271;s:26:"start_brackets_token_index";i:9241;s:23:"end_brackets_line_index";i:1299;s:24:"end_brackets_token_index";i:9490;s:14:"end_line_index";i:1299;s:15:"end_token_index";i:9490;}s:30:"getCodeWithoutCommentsFromFile";a:20:{s:4:"name";s:30:"getCodeWithoutCommentsFromFile";s:16:"start_line_index";i:1353;s:17:"start_token_index";i:9494;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:1553:"/* This is DEPRECATED bc if php is obfuscated this doesn't work.
	public static function getFunctionCodeFromFile($file_path, $function_name, $class_name = 0) {
		if ($file_path && file_exists($file_path) && $function_name) {
			$f = self::getFunctionFromFile($file_path, $function_name, $class_name);
			$function_name = $f["name"];
			$start_brackets_line = $f["start_brackets_line_index"];
			$end_line = $f["end_line_index"];
			
			if (is_numeric($start_brackets_line)) {
				$contents = file_get_contents($file_path);
				$contents = str_replace("\r\n", "\n", $contents);
				$lines = explode("\n", $contents);
				
				//TODO: change this code to work with obfuscated php
				
				$code = "";
				
				$line = $lines[ $start_brackets_line - 1 ];
				$pos = strpos($line, "{");
				$pos = $pos !== false ? $pos : strlen($line);
				$new_c = trim(substr($line, $pos + 1));
				if ($new_c)
					$code .= "$new_c";
				
				$idx = $start_brackets_line - 1;
				while (true) {
					++$idx;
					
					if ($idx + 1 >= $end_line) 
						break;
					
					$l = str_replace("\n", "", $lines[$idx]);
					$l = $l[0] == "\t" ? substr($l, 1) : $l;
					if ($class_name)//it executes twice if it is a method.
						$l = $l[0] == "\t" ? substr($l, 1) : $l;
					
					$code .= "\n$l";
				}
				
				$line = $lines[ $end_line - 1 ];
				$pos = strpos($line, "}");
				$pos = $pos !== false ? $pos : strlen($line);
				$new_c = trim(substr($line, 0, $pos));
				if ($new_c) 
					$code .= "\n$new_c";
				
				return trim($code);
			}
		}
		
		return false;
	}*/";}s:25:"start_comments_line_index";i:1300;s:26:"start_comments_token_index";i:9492;s:23:"end_comments_line_index";i:1300;s:24:"end_comments_token_index";i:9492;s:22:"start_args_token_index";i:9501;s:20:"end_args_token_index";i:9503;s:9:"arguments";a:1:{s:10:"$file_path";N;}s:25:"start_brackets_line_index";i:1353;s:26:"start_brackets_token_index";i:9505;s:23:"end_brackets_line_index";i:1358;s:24:"end_brackets_token_index";i:9544;s:14:"end_line_index";i:1358;s:15:"end_token_index";i:9544;}s:22:"getCodeWithoutComments";a:15:{s:4:"name";s:22:"getCodeWithoutComments";s:16:"start_line_index";i:1360;s:17:"start_token_index";i:9546;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:9553;s:20:"end_args_token_index";i:9555;s:9:"arguments";a:1:{s:5:"$code";N;}s:25:"start_brackets_line_index";i:1360;s:26:"start_brackets_token_index";i:9557;s:23:"end_brackets_line_index";i:1388;s:24:"end_brackets_token_index";i:9740;s:14:"end_line_index";i:1388;s:15:"end_token_index";i:9740;}s:19:"renameClassFromFile";a:20:{s:4:"name";s:19:"renameClassFromFile";s:16:"start_line_index";i:1393;s:17:"start_token_index";i:9748;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:3:{i:0;s:18:"/* END: GETTERS */";i:1;s:20:"/* START: RENAMES */";i:2;s:82:"//$old_class_name and $new_class_name must be the full class names with namespaces";}s:25:"start_comments_line_index";i:1389;s:26:"start_comments_token_index";i:9742;s:23:"end_comments_line_index";i:1392;s:24:"end_comments_token_index";i:9746;s:22:"start_args_token_index";i:9755;s:20:"end_args_token_index";i:9763;s:9:"arguments";a:3:{s:10:"$file_path";N;s:15:"$old_class_name";N;s:15:"$new_class_name";N;}s:25:"start_brackets_line_index";i:1393;s:26:"start_brackets_token_index";i:9765;s:23:"end_brackets_line_index";i:1407;s:24:"end_brackets_token_index";i:9921;s:14:"end_line_index";i:1407;s:15:"end_token_index";i:9921;}s:22:"renameFunctionFromFile";a:15:{s:4:"name";s:22:"renameFunctionFromFile";s:16:"start_line_index";i:1409;s:17:"start_token_index";i:9923;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:9930;s:20:"end_args_token_index";i:9945;s:9:"arguments";a:4:{s:10:"$file_path";N;s:14:"$old_func_name";N;s:14:"$new_func_name";N;s:11:"$class_name";s:1:"0";}s:25:"start_brackets_line_index";i:1409;s:26:"start_brackets_token_index";i:9947;s:23:"end_brackets_line_index";i:1421;s:24:"end_brackets_token_index";i:10053;s:14:"end_line_index";i:1421;s:15:"end_token_index";i:10053;}s:17:"editClassFromFile";a:20:{s:4:"name";s:17:"editClassFromFile";s:16:"start_line_index";i:1425;s:17:"start_token_index";i:10059;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:18:"/* END: RENAMES */";i:1;s:18:"/* START: EDITS */";}s:25:"start_comments_line_index";i:1422;s:26:"start_comments_token_index";i:10055;s:23:"end_comments_line_index";i:1424;s:24:"end_comments_token_index";i:10057;s:22:"start_args_token_index";i:10066;s:20:"end_args_token_index";i:10074;s:9:"arguments";a:3:{s:10:"$file_path";N;s:19:"$old_class_settings";N;s:19:"$new_class_settings";N;}s:25:"start_brackets_line_index";i:1425;s:26:"start_brackets_token_index";i:10076;s:23:"end_brackets_line_index";i:1502;s:24:"end_brackets_token_index";i:10905;s:14:"end_line_index";i:1502;s:15:"end_token_index";i:10905;}s:20:"editFunctionFromFile";a:20:{s:4:"name";s:20:"editFunctionFromFile";s:16:"start_line_index";i:1610;s:17:"start_token_index";i:10909;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:4094:"/* This is DEPRECATED bc if php is obfuscated this doesn't work.
	public static function editClassFromFile($file_path, $old_class_settings, $new_class_settings) {
		$old_class_name = self::prepareClassNameWithNameSpace($old_class_settings["name"], $old_class_settings["namespace"]);
		
		if ($file_path && file_exists($file_path) && $old_class_name && $new_class_settings["name"]) {
			$c = self::getClassFromFile($file_path, $old_class_name);
			
			$old_class_name = $c["name"];
			$start_line = $c["start_line_index"];
			$start_brackets_line = $c["start_brackets_line_index"];
			
			if (is_numeric($start_line)) {
				$contents = file_get_contents($file_path);
				$contents = str_replace("\r\n", "\n", $contents);
				$lines = explode("\n", $contents);
				
				//TODO: change this code to work with obfuscated php
				
				$new_contents = implode("\n", array_slice($lines, 0, $start_line - 1) );
				
				$line = $lines[ $start_line - 1 ];
				$new_c = "";
				$parts = explode(" ", $line);
				$t = count($parts);
				for ($i = 0; $i < $t; $i++) {
					if (strtolower(trim($parts[$i])) == "class" || strtolower(trim($parts[$i])) == "abstract") 
						break;
					else 
						$new_c .= ($i > 0 ? " " : "") . $parts[$i];
				}
				
				$new_c = trim($new_c);
				if ($new_c) 
					$new_contents .= "\n$new_c";
				
				//remove namespace from $new_class_settings bc they will be take care after
				$new_namespace = $new_class_settings["namespace"];
				$new_includes = $new_class_settings["includes"];
				$new_uses = $new_class_settings["uses"];
				$new_class_settings["namespace"] = null;
				$new_class_settings["includes"] = null;
				$new_class_settings["uses"] = null;
				
				$new_contents .= "\n" . self::getClassString($new_class_settings);
				
				if ($start_brackets_line == $start_line) 
					$pos = strpos($line, "{", strpos($line, $old_class_name) + 1);
				else {
					$line = $lines[ $start_brackets_line - 1 ];
					$pos = strpos($line, "{");
				}
				
				$pos = $pos !== false ? $pos : strlen($line);
				$new_c = trim(substr($line, $pos));
				if ($new_c) 
					$new_contents .= " $new_c";
				
				$new_contents .= "\n" . implode("\n", array_slice($lines, $start_brackets_line) );
				
				$new_contents = str_replace("\n\n\n", "\n\n", str_replace("\t\n", "\n", $new_contents));
				
				if (file_put_contents($file_path, $new_contents) > 0) {
					$status = true;
					$new_class_settings["namespace"] = $new_namespace;
					
					//update namespace if different
					if ($old_class_settings["namespace"] != $new_class_settings["namespace"] && ($old_class_settings["namespace"] || $new_class_settings["namespace"])) 
						$status = self::replaceNamespaceFromFile($file_path, $old_class_settings["namespace"], $new_class_settings["namespace"]);
					
					
					//add includes and uses to the begining of file or after the first namespace
					if ($status && ($new_includes || $new_uses)) {
						$new_c = "";
						
						if ($new_includes)
							foreach ($new_includes as $include)
								if (is_array($include) && trim($include[0]))
									$new_c .= "include" . ($include[1] ? "_once" : "") . " " . $include[0] . ";\n";
								else if (!is_array($include) && trim($include))
									$new_c .= "include_once $include;\n";
						
						if ($new_uses)
							foreach ($new_uses as $use => $alias)
								if (trim($use))
									$new_c .= "use $use" . (trim($alias) ? " as $alias" : "") . ";\n";
						
						$status = self::addCodeToBeginOfFileOrAfterFirstNamespace($file_path, $new_c);
					}
					
					if ($status && isset($new_class_settings["code"])) {
						$new_class_name = self::prepareClassNameWithNameSpace($new_class_settings["name"], $new_class_settings["namespace"]);
						
						$status = self::removeClassPropertiesFromFile($file_path, $new_class_name) && self::addClassPropertiesToFile($file_path, $new_class_name, $new_class_settings["code"]);
					}
					
					//if status false, re-save the old code
					if (!$status)
						file_put_contents($file_path, $contents);
					
					return $status;
				}
			}
		}
		
		return false;
	}*/";}s:25:"start_comments_line_index";i:1503;s:26:"start_comments_token_index";i:10907;s:23:"end_comments_line_index";i:1503;s:24:"end_comments_token_index";i:10907;s:22:"start_args_token_index";i:10916;s:20:"end_args_token_index";i:10931;s:9:"arguments";a:4:{s:10:"$file_path";N;s:18:"$old_func_settings";N;s:18:"$new_func_settings";N;s:11:"$class_name";s:1:"0";}s:25:"start_brackets_line_index";i:1610;s:26:"start_brackets_token_index";i:10933;s:23:"end_brackets_line_index";i:1652;s:24:"end_brackets_token_index";i:11364;s:14:"end_line_index";i:1652;s:15:"end_token_index";i:11364;}s:25:"editClassCommentsFromFile";a:20:{s:4:"name";s:25:"editClassCommentsFromFile";s:16:"start_line_index";i:1715;s:17:"start_token_index";i:11368;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:2214:"/* This is DEPRECATED bc if php is obfuscated this doesn't work.
	public static function editFunctionFromFile($file_path, $old_func_settings, $new_func_settings, $class_name = 0) {
		$old_func_name = $old_func_settings["name"];
		
		if ($file_path && file_exists($file_path) && $old_func_name && $new_func_settings["name"]) {
			$f = self::getFunctionFromFile($file_path, $old_func_name, $class_name);
			$old_func_name = $f["name"];
			$start_line = $f["start_line_index"];
			$start_brackets_line = $f["start_brackets_line_index"];
			$end_line = $f["end_line_index"];
			
			if (is_numeric($start_line)) {
				$contents = file_get_contents($file_path);
				$contents = str_replace("\r\n", "\n", $contents);
				$lines = explode("\n", $contents);
				
				//TODO: change this code to work with obfuscated php
				
				$new_contents = implode("\n", array_slice($lines, 0, $start_line - 1) );
				
				$line = $lines[ $start_line - 1 ];
				$new_c = "";
				$parts = explode(" ", $line);
				$available_types = array("public", "private", "protected", "abstract", "static", "function");
				$t = count($parts);
				for ($i = 0; $i < $t; $i++) {
					if (in_array(strtolower(trim($parts[$i])), $available_types)) {
						break;
					}
					else {
						$new_c .= ($i > 0 ? " " : "") . $parts[$i];
					}
				}
				$new_c = trim($new_c);
				if ($new_c) 
					$new_contents .= "\n$new_c";
				
				$new_contents .= "\n" . self::getFunctionString($new_func_settings, $class_name);
				
				$line = $lines[ $start_brackets_line - 1 ];
				$pos = strpos($line, "{");
				$pos = $pos !== false ? $pos : strlen($line);
				$new_c = trim(substr($line, $pos));
				if ($new_c) 
					$new_contents .= " $new_c";
				
				$new_contents .= "\n" . implode("\n", array_slice($lines, $start_brackets_line) );
				
				$new_contents = str_replace("\n\n\n", "\n\n", str_replace("\t\n", "\n", $new_contents));
				if (file_put_contents($file_path, $new_contents) > 0) {
					$status = true;
					if (isset($new_func_settings["code"])) 
						$status = self::replaceFunctionCodeFromFile($file_path, $new_func_settings["name"], $new_func_settings["code"], $class_name);
					
					return $status;
				}
			}
		}
		
		return false;
	}*/";}s:25:"start_comments_line_index";i:1653;s:26:"start_comments_token_index";i:11366;s:23:"end_comments_line_index";i:1653;s:24:"end_comments_token_index";i:11366;s:22:"start_args_token_index";i:11375;s:20:"end_args_token_index";i:11383;s:9:"arguments";a:3:{s:10:"$file_path";N;s:11:"$class_name";N;s:9:"$comments";N;}s:25:"start_brackets_line_index";i:1715;s:26:"start_brackets_token_index";i:11385;s:23:"end_brackets_line_index";i:1757;s:24:"end_brackets_token_index";i:11801;s:14:"end_line_index";i:1757;s:15:"end_token_index";i:11801;}s:28:"editFunctionCommentsFromFile";a:20:{s:4:"name";s:28:"editFunctionCommentsFromFile";s:16:"start_line_index";i:1767;s:17:"start_token_index";i:11805;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:320:"/* This is DEPRECATED bc if php is obfuscated this doesn't work.
	public static function editClassCommentsFromFile($file_path, $class_name, $comments) {
		if ($class_name) {
			$c = self::getClassFromFile($file_path, $class_name);
			return self::editCommentsFromFile($file_path, $c, $comments);
		}
		return false;
	}*/";}s:25:"start_comments_line_index";i:1758;s:26:"start_comments_token_index";i:11803;s:23:"end_comments_line_index";i:1758;s:24:"end_comments_token_index";i:11803;s:22:"start_args_token_index";i:11812;s:20:"end_args_token_index";i:11827;s:9:"arguments";a:4:{s:10:"$file_path";N;s:10:"$func_name";N;s:9:"$comments";N;s:11:"$class_name";s:1:"0";}s:25:"start_brackets_line_index";i:1767;s:26:"start_brackets_token_index";i:11829;s:23:"end_brackets_line_index";i:1812;s:24:"end_brackets_token_index";i:12298;s:14:"end_line_index";i:1812;s:15:"end_token_index";i:12298;}s:24:"removeNamespacesFromFile";a:20:{s:4:"name";s:24:"removeNamespacesFromFile";s:16:"start_line_index";i:1885;s:17:"start_token_index";i:12308;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:4:{i:0;s:353:"/* This is DEPRECATED bc if php is obfuscated this doesn't work.
	public static function editFunctionCommentsFromFile($file_path, $func_name, $comments, $class_name = 0) {
		if ($func_name) {
			$f = self::getFunctionFromFile($file_path, $func_name, $class_name);
			return self::editCommentsFromFile($file_path, $f, $comments);
		}
		return false;
	}*/";i:1;s:2250:"/* This is DEPRECATED bc if php is obfuscated this doesn't work.
	private static function editCommentsFromFile($file_path, $obj_settings, $comments) {
		if ($file_path && file_exists($file_path)) {
		//echo "<pre>";print_r($obj_settings);die();
			$start_line = $obj_settings["start_comments_line_index"];
			$end_line = $obj_settings["end_comments_line_index"];
			
			if (is_numeric($start_line) || $comments) {
				if (!is_numeric($start_line)) {
					$start_line = $obj_settings["start_line_index"];
					$end_line = $obj_settings["start_line_index"];
				}
				
				$contents = file_get_contents($file_path);
				$contents = str_replace("\r\n", "\n", $contents);
				$lines = explode("\n", $contents);
				
				//TODO: change this code to work with obfuscated php
				
				$new_contents = implode("\n", array_slice($lines, 0, $start_line - 1) );
				
				$line = $lines[ $start_line - 1 ];
				$simple_comment_pos = strpos($line, "//");
				$multiple_comment_pos = strpos($line, "/*");
				
				$pos = $simple_comment_pos !== false && ($simple_comment_pos < $multiple_comment_pos || $multiple_comment_pos == false) ? $simple_comment_pos : $multiple_comment_pos;
				
				if ($pos !== false) {
					$c = substr($line, 0, $pos);
					$new_contents .= "\n" . (trim($c) ? $c : "");
					$new_contents .= trim($comments) ? "\n" . $comments : "";
					
					$line = $lines[ $end_line - 1 ];
					$simple_comment_pos = strrpos($line, "//");
					$multiple_comment_pos = strrpos($line, "*" . "/"); //"*" . "/" only bc this code is commented
					
					if ($simple_comment_pos === false && $multiple_comment_pos === false) {
						$new_contents .= trim($line) ? $line : "";
					}
					else if ($multiple_comment_pos !== false) {
						$c = substr($line, $multiple_comment_pos + 2);
						$new_contents .= trim($c) ? $c : "";
					}
				}
				else {
					$new_contents .= trim($comments) ? "\n" . $comments : "";
					$new_contents .= "\n" .  (trim($line) ? $line : "");
				}
				
				$new_contents .= "\n" . implode("\n", array_slice($lines, $end_line) );
				
				$new_contents = str_replace("\n\n\n", "\n\n", str_replace("\t\n", "\n", $new_contents));
				
				return file_put_contents($file_path, $new_contents) > 0;
			}
		}
		
		return false;
	}*/";i:2;s:16:"/* END: EDITS */";i:3;s:20:"/* START: REMOVES */";}s:25:"start_comments_line_index";i:1813;s:26:"start_comments_token_index";i:12300;s:23:"end_comments_line_index";i:1883;s:24:"end_comments_token_index";i:12306;s:22:"start_args_token_index";i:12315;s:20:"end_args_token_index";i:12317;s:9:"arguments";a:1:{s:10:"$file_path";N;}s:25:"start_brackets_line_index";i:1885;s:26:"start_brackets_token_index";i:12319;s:23:"end_brackets_line_index";i:1887;s:24:"end_brackets_token_index";i:12334;s:14:"end_line_index";i:1887;s:15:"end_token_index";i:12334;}s:18:"removeUsesFromFile";a:15:{s:4:"name";s:18:"removeUsesFromFile";s:16:"start_line_index";i:1889;s:17:"start_token_index";i:12336;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:12343;s:20:"end_args_token_index";i:12345;s:9:"arguments";a:1:{s:10:"$file_path";N;}s:25:"start_brackets_line_index";i:1889;s:26:"start_brackets_token_index";i:12347;s:23:"end_brackets_line_index";i:1891;s:24:"end_brackets_token_index";i:12362;s:14:"end_line_index";i:1891;s:15:"end_token_index";i:12362;}s:22:"removeIncludesFromFile";a:15:{s:4:"name";s:22:"removeIncludesFromFile";s:16:"start_line_index";i:1893;s:17:"start_token_index";i:12364;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:12371;s:20:"end_args_token_index";i:12373;s:9:"arguments";a:1:{s:10:"$file_path";N;}s:25:"start_brackets_line_index";i:1893;s:26:"start_brackets_token_index";i:12375;s:23:"end_brackets_line_index";i:1896;s:24:"end_brackets_token_index";i:12409;s:14:"end_line_index";i:1896;s:15:"end_token_index";i:12409;}s:23:"removeNamespaceFromFile";a:20:{s:4:"name";s:23:"removeNamespaceFromFile";s:16:"start_line_index";i:1974;s:17:"start_token_index";i:12809;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:1148:"/* This is DEPRECATED bc if php is obfuscated this doesn't work.
	private static function removeInstructionsFromFile($file_path, $types) {
		if ($file_path && file_exists($file_path) && $types) {
			$types = is_array($types) ? $types : array($types);
			
			$contents = file_get_contents($file_path);
			$contents = str_replace("\r\n", "\n", $contents);
			$lines = explode("\n", $contents);
			
			//TODO: change this code to work with obfuscated php
			
			$new_contents = "";
			
			$t = count($lines);
			for ($i = 0; $i < $t; $i++) {
				$line = $lines[$i];
				$trimmed = trim($line);
				$exists = false;
				
				foreach ($types as $type) 
					if (stripos($trimmed, $type) === 0) {
						$fc = substr($trimmed, strlen($type), 1);
						
						if ($fc == " " || $fc == '$' || $fc == "'" || $fc == '"' || $fc == ";") {
							$exists = true;
							break;
						}
					}
				
				if (!$exists)
					$new_contents .= ($new_contents ? "\n" : "") . $line;
			}
			
			$new_contents = str_replace("\n\n\n", "\n\n", str_replace("\t\n", "\n", $new_contents));
			return file_put_contents($file_path, $new_contents) > 0;
		}
		
		return false;
	}*/";}s:25:"start_comments_line_index";i:1934;s:26:"start_comments_token_index";i:12807;s:23:"end_comments_line_index";i:1934;s:24:"end_comments_token_index";i:12807;s:22:"start_args_token_index";i:12816;s:20:"end_args_token_index";i:12821;s:9:"arguments";a:2:{s:10:"$file_path";N;s:10:"$namespace";N;}s:25:"start_brackets_line_index";i:1974;s:26:"start_brackets_token_index";i:12823;s:23:"end_brackets_line_index";i:1976;s:24:"end_brackets_token_index";i:12841;s:14:"end_line_index";i:1976;s:15:"end_token_index";i:12841;}s:17:"removeUseFromFile";a:15:{s:4:"name";s:17:"removeUseFromFile";s:16:"start_line_index";i:1978;s:17:"start_token_index";i:12843;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:12850;s:20:"end_args_token_index";i:12855;s:9:"arguments";a:2:{s:10:"$file_path";N;s:4:"$use";N;}s:25:"start_brackets_line_index";i:1978;s:26:"start_brackets_token_index";i:12857;s:23:"end_brackets_line_index";i:1980;s:24:"end_brackets_token_index";i:12875;s:14:"end_line_index";i:1980;s:15:"end_token_index";i:12875;}s:21:"removeIncludeFromFile";a:15:{s:4:"name";s:21:"removeIncludeFromFile";s:16:"start_line_index";i:1982;s:17:"start_token_index";i:12877;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:12884;s:20:"end_args_token_index";i:12889;s:9:"arguments";a:2:{s:10:"$file_path";N;s:8:"$include";N;}s:25:"start_brackets_line_index";i:1982;s:26:"start_brackets_token_index";i:12891;s:23:"end_brackets_line_index";i:1985;s:24:"end_brackets_token_index";i:12928;s:14:"end_line_index";i:1985;s:15:"end_token_index";i:12928;}s:29:"removeClassPropertiesFromFile";a:15:{s:4:"name";s:29:"removeClassPropertiesFromFile";s:16:"start_line_index";i:2032;s:17:"start_token_index";i:13393;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:13400;s:20:"end_args_token_index";i:13405;s:9:"arguments";a:2:{s:10:"$file_path";N;s:11:"$class_name";N;}s:25:"start_brackets_line_index";i:2032;s:26:"start_brackets_token_index";i:13407;s:23:"end_brackets_line_index";i:2089;s:24:"end_brackets_token_index";i:13912;s:14:"end_line_index";i:2089;s:15:"end_token_index";i:13912;}s:19:"removeClassFromFile";a:20:{s:4:"name";s:19:"removeClassFromFile";s:16:"start_line_index";i:2147;s:17:"start_token_index";i:13916;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:1892:"/* This is DEPRECATED bc if php is obfuscated this doesn't work.
	public static function removeClassPropertiesFromFile($file_path, $class_name) {
		if ($file_path && file_exists($file_path) && $class_name) {
			$c = self::getClassFromFile($file_path, $class_name);
			$start_brackets_line = $c["start_brackets_line_index"];
			
			if (is_numeric($start_brackets_line)) {
				$contents = file_get_contents($file_path);
				$contents = str_replace("\r\n", "\n", $contents);
				$lines = explode("\n", $contents);
				
				//TODO: change this code to work with obfuscated php
				
				$new_contents = implode("\n", array_slice($lines, 0, $start_brackets_line - 1) );
				
				$line = $lines[ $start_brackets_line - 1 ];
				$pos = strpos($line, "{");
				$pos = $pos !== false ? $pos : strlen($line);
				$new_contents .= "\n" . substr($line, 0, $pos + 1);
				
				$intervals = array();
				$t = $c["methods"] ? count($c["methods"]) : 0;
				for ($i = 0; $i < $t; $i++) {
					$method = $c["methods"][$i];
					$sl = is_numeric($method["start_comments_line_index"]) ? $method["start_comments_line_index"] : $method["start_line_index"];
					$intervals[] = array($sl, $method["end_line_index"], $method);
				}
				
				$idx = $start_brackets_line - 1;
				while (true) {
					++$idx;
					
					if ($idx + 1 >= $c["end_line_index"]) 
						break;
					
					foreach ($intervals as $interval) {
						if ($idx + 1 >= $interval[0] && $idx + 1 <= $interval[1]) {
							if ($idx + 1 == $interval[0]) {
								$new_contents .= "\n";
							}
							
							$new_contents .= "\n" . $lines[$idx];
							break;
						}
					}
				}
				
				$new_contents .= "\n" . implode("\n", array_slice($lines, $idx) );
				
				$new_contents = str_replace("\n\n\n", "\n\n", str_replace("\t\n", "\n", $new_contents));
				return file_put_contents($file_path, $new_contents) > 0;
			}
		}
		
		return false;
	}*/";}s:25:"start_comments_line_index";i:2090;s:26:"start_comments_token_index";i:13914;s:23:"end_comments_line_index";i:2090;s:24:"end_comments_token_index";i:13914;s:22:"start_args_token_index";i:13923;s:20:"end_args_token_index";i:13928;s:9:"arguments";a:2:{s:10:"$file_path";N;s:11:"$class_name";N;}s:25:"start_brackets_line_index";i:2147;s:26:"start_brackets_token_index";i:13930;s:23:"end_brackets_line_index";i:2189;s:24:"end_brackets_token_index";i:14325;s:14:"end_line_index";i:2189;s:15:"end_token_index";i:14325;}s:22:"removeFunctionFromFile";a:20:{s:4:"name";s:22:"removeFunctionFromFile";s:16:"start_line_index";i:2216;s:17:"start_token_index";i:14329;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:1006:"/* This is DEPRECATED bc if php is obfuscated this doesn't work.
	public static function removeClassFromFile($file_path, $class_name) {
		$class_name = $class_name ? trim($class_name) : $class_name;
		
		if ($file_path && file_exists($file_path) && $class_name) {
			self::editClassCommentsFromFile($file_path, $class_name, "");
			
			$contents = file_get_contents($file_path);
			$contents = str_replace("\r\n", "\n", $contents);
			
			$c = self::getClassFromFile($file_path, $class_name);
			$start_line = $c["start_line_index"];
			$end_line = $c["end_line_index"];
			
			//TODO: change this code to work with obfuscated php
			
			$available_types = array("class", "abstract");
			$new_contents = self::removeItemFromContents($contents, $start_line, $end_line, $available_types);
			
			$new_contents = str_replace("\n\n\n", "\n\n", str_replace("\t\n", "\n", $new_contents));
			return $contents != $new_contents ? file_put_contents($file_path, $new_contents) > 0 : true;
		}
		
		return false;
	}*/";}s:25:"start_comments_line_index";i:2190;s:26:"start_comments_token_index";i:14327;s:23:"end_comments_line_index";i:2190;s:24:"end_comments_token_index";i:14327;s:22:"start_args_token_index";i:14336;s:20:"end_args_token_index";i:14348;s:9:"arguments";a:3:{s:10:"$file_path";N;s:10:"$func_name";N;s:11:"$class_name";s:1:"0";}s:25:"start_brackets_line_index";i:2216;s:26:"start_brackets_token_index";i:14350;s:23:"end_brackets_line_index";i:2258;s:24:"end_brackets_token_index";i:14748;s:14:"end_line_index";i:2258;s:15:"end_token_index";i:14748;}s:27:"replaceFunctionCodeFromFile";a:20:{s:4:"name";s:27:"replaceFunctionCodeFromFile";s:16:"start_line_index";i:2287;s:17:"start_token_index";i:14756;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:3:{i:0;s:1090:"/* This is DEPRECATED bc if php is obfuscated this doesn't work.
	public static function removeFunctionFromFile($file_path, $func_name, $class_name = 0) {
		$func_name = $func_name ? trim($func_name) : false;
		
		if ($file_path && file_exists($file_path) && $func_name) {
			self::editFunctionCommentsFromFile($file_path, $func_name, "", $class_name);
			
			$f = self::getFunctionFromFile($file_path, $func_name, $class_name);
			$start_line = $f["start_line_index"];
			$end_line = $f["end_line_index"];
			
			$contents = file_get_contents($file_path);
			$contents = str_replace("\r\n", "\n", $contents);
			
			//TODO: change this code to work with obfuscated php
			
			$available_types = array("public", "private", "protected", "abstract", "static", "function");
			$new_contents = self::removeItemFromContents($contents, $start_line, $end_line, $available_types);
	
			$new_contents = str_replace("\n\n\n", "\n\n", str_replace("\t\n", "\n", $new_contents));
			return $contents != $new_contents ? file_put_contents($file_path, $new_contents) > 0 : true;
		}
		
		return false;
	}*/";i:1;s:18:"/* END: REMOVES */";i:2;s:21:"/* START: REPLACES */";}s:25:"start_comments_line_index";i:2259;s:26:"start_comments_token_index";i:14750;s:23:"end_comments_line_index";i:2286;s:24:"end_comments_token_index";i:14754;s:22:"start_args_token_index";i:14763;s:20:"end_args_token_index";i:14778;s:9:"arguments";a:4:{s:10:"$file_path";N;s:10:"$func_name";N;s:5:"$code";N;s:11:"$class_name";s:1:"0";}s:25:"start_brackets_line_index";i:2287;s:26:"start_brackets_token_index";i:14780;s:23:"end_brackets_line_index";i:2327;s:24:"end_brackets_token_index";i:15246;s:14:"end_line_index";i:2327;s:15:"end_token_index";i:15246;}s:24:"replaceNamespaceFromFile";a:20:{s:4:"name";s:24:"replaceNamespaceFromFile";s:16:"start_line_index";i:2374;s:17:"start_token_index";i:15250;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:1724:"/* This is DEPRECATED bc if php is obfuscated this doesn't work.
	public static function replaceFunctionCodeFromFile($file_path, $function_name, $code, $class_name = 0) {
		if ($file_path && file_exists($file_path) && $function_name) {
			$f = self::getFunctionFromFile($file_path, $function_name, $class_name);
			$function_name = $f["name"];
			$start_brackets_line = $f["start_brackets_line_index"];
			$end_line = $f["end_line_index"];
			
			if (is_numeric($start_brackets_line)) {
				$contents = file_get_contents($file_path);
				$contents = str_replace("\r\n", "\n", $contents);
				$lines = explode("\n", $contents);
				
				//TODO: change this code to work with obfuscated php
				
				$prefix = $class_name ? "\t" : "";
				
				$new_contents = implode("\n", array_slice($lines, 0, $start_brackets_line - 1) );
				
				$line = $lines[ $start_brackets_line - 1 ];
				$pos = strpos($line, "{");
				$pos = $pos !== false ? $pos : strlen($line);
				$new_c = trim(substr($line, 0, $pos + 1));
				if ($new_c)
					$new_contents .= "\n$prefix$new_c";
				
				$code = $code ? $code : "";
				$new_contents .= $class_name ? "\n$prefix$prefix" . str_replace("\n", "\n$prefix$prefix", $code) : "\n\t" . str_replace("\n", "\n\t", $code);
				
				$line = $lines[ $end_line - 1 ];
				$pos = strpos($line, "}");
				$pos = $pos !== false ? $pos : 0;
				$new_c = trim(substr($line, $pos));
				if ($new_c)
					$new_contents .= "\n$prefix$new_c";
				
				$new_contents .= "\n" . implode("\n", array_slice($lines, $end_line) );
			
				$new_contents = str_replace("\n\n\n", "\n\n", str_replace("\t\n", "\n", $new_contents));
				return file_put_contents($file_path, $new_contents) > 0;
			}
		}
		
		return false;
	}*/";}s:25:"start_comments_line_index";i:2328;s:26:"start_comments_token_index";i:15248;s:23:"end_comments_line_index";i:2328;s:24:"end_comments_token_index";i:15248;s:22:"start_args_token_index";i:15257;s:20:"end_args_token_index";i:15265;s:9:"arguments";a:3:{s:10:"$file_path";N;s:14:"$old_namespace";N;s:14:"$new_namespace";N;}s:25:"start_brackets_line_index";i:2374;s:26:"start_brackets_token_index";i:15267;s:23:"end_brackets_line_index";i:2394;s:24:"end_brackets_token_index";i:15472;s:14:"end_line_index";i:2394;s:15:"end_token_index";i:15472;}s:19:"addNamespacesToFile";a:20:{s:4:"name";s:19:"addNamespacesToFile";s:16:"start_line_index";i:2398;s:17:"start_token_index";i:15478;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:19:"/* END: REPLACES */";i:1;s:17:"/* START: ADDS */";}s:25:"start_comments_line_index";i:2395;s:26:"start_comments_token_index";i:15474;s:23:"end_comments_line_index";i:2397;s:24:"end_comments_token_index";i:15476;s:22:"start_args_token_index";i:15485;s:20:"end_args_token_index";i:15490;s:9:"arguments";a:2:{s:10:"$file_path";N;s:11:"$namespaces";N;}s:25:"start_brackets_line_index";i:2398;s:26:"start_brackets_token_index";i:15492;s:23:"end_brackets_line_index";i:2413;s:24:"end_brackets_token_index";i:15618;s:14:"end_line_index";i:2413;s:15:"end_token_index";i:15618;}s:13:"addUsesToFile";a:15:{s:4:"name";s:13:"addUsesToFile";s:16:"start_line_index";i:2415;s:17:"start_token_index";i:15620;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:15627;s:20:"end_args_token_index";i:15632;s:9:"arguments";a:2:{s:10:"$file_path";N;s:5:"$uses";N;}s:25:"start_brackets_line_index";i:2415;s:26:"start_brackets_token_index";i:15634;s:23:"end_brackets_line_index";i:2427;s:24:"end_brackets_token_index";i:15728;s:14:"end_line_index";i:2427;s:15:"end_token_index";i:15728;}s:17:"addIncludesToFile";a:15:{s:4:"name";s:17:"addIncludesToFile";s:16:"start_line_index";i:2429;s:17:"start_token_index";i:15730;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:15737;s:20:"end_args_token_index";i:15742;s:9:"arguments";a:2:{s:10:"$file_path";N;s:9:"$includes";N;}s:25:"start_brackets_line_index";i:2429;s:26:"start_brackets_token_index";i:15744;s:23:"end_brackets_line_index";i:2443;s:24:"end_brackets_token_index";i:15879;s:14:"end_line_index";i:2443;s:15:"end_token_index";i:15879;}s:20:"addCodeToBeginOfFile";a:15:{s:4:"name";s:20:"addCodeToBeginOfFile";s:16:"start_line_index";i:2445;s:17:"start_token_index";i:15881;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:15888;s:20:"end_args_token_index";i:15893;s:9:"arguments";a:2:{s:10:"$file_path";N;s:5:"$code";N;}s:25:"start_brackets_line_index";i:2445;s:26:"start_brackets_token_index";i:15895;s:23:"end_brackets_line_index";i:2458;s:24:"end_brackets_token_index";i:16029;s:14:"end_line_index";i:2458;s:15:"end_token_index";i:16029;}s:41:"addCodeToBeginOfFileOrAfterFirstNamespace";a:15:{s:4:"name";s:41:"addCodeToBeginOfFileOrAfterFirstNamespace";s:16:"start_line_index";i:2460;s:17:"start_token_index";i:16031;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:16038;s:20:"end_args_token_index";i:16043;s:9:"arguments";a:2:{s:10:"$file_path";N;s:5:"$code";N;}s:25:"start_brackets_line_index";i:2460;s:26:"start_brackets_token_index";i:16045;s:23:"end_brackets_line_index";i:2487;s:24:"end_brackets_token_index";i:16281;s:14:"end_line_index";i:2487;s:15:"end_token_index";i:16281;}s:14:"addClassToFile";a:15:{s:4:"name";s:14:"addClassToFile";s:16:"start_line_index";i:2489;s:17:"start_token_index";i:16283;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:16290;s:20:"end_args_token_index";i:16295;s:9:"arguments";a:2:{s:10:"$file_path";N;s:15:"$class_settings";N;}s:25:"start_brackets_line_index";i:2489;s:26:"start_brackets_token_index";i:16297;s:23:"end_brackets_line_index";i:2519;s:24:"end_brackets_token_index";i:16602;s:14:"end_line_index";i:2519;s:15:"end_token_index";i:16602;}s:24:"addClassPropertiesToFile";a:15:{s:4:"name";s:24:"addClassPropertiesToFile";s:16:"start_line_index";i:2521;s:17:"start_token_index";i:16604;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:16611;s:20:"end_args_token_index";i:16619;s:9:"arguments";a:3:{s:10:"$file_path";N;s:11:"$class_name";N;s:5:"$code";N;}s:25:"start_brackets_line_index";i:2521;s:26:"start_brackets_token_index";i:16621;s:23:"end_brackets_line_index";i:2549;s:24:"end_brackets_token_index";i:16898;s:14:"end_line_index";i:2549;s:15:"end_token_index";i:16898;}s:17:"addFunctionToFile";a:20:{s:4:"name";s:17:"addFunctionToFile";s:16:"start_line_index";i:2587;s:17:"start_token_index";i:16902;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:1338:"/* This is DEPRECATED bc if php is obfuscated this doesn't work.
	public static function addClassPropertiesToFile($file_path, $class_name, $code) {
		if ($file_path && file_exists($file_path) && $class_name && $code) {
			$c = self::getClassFromFile($file_path, $class_name);
			$start_brackets_line = $c["start_brackets_line_index"];
			
			if (is_numeric($start_brackets_line)) {
				$contents = file_get_contents($file_path);
				$contents = str_replace("\r\n", "\n", $contents);
				$lines = explode("\n", $contents);
				
				//TODO: change this code to work with obfuscated php
				
				$new_contents = implode("\n", array_slice($lines, 0, $start_brackets_line - 1) );
				
				$line = $lines[ $start_brackets_line - 1 ];
				$pos = strpos($line, "{");
				$pos = $pos !== false ? $pos : strlen($line);
				$new_contents .= "\n" . substr($line, 0, $pos + 1);
				
				$new_contents .= "\n\t" . str_replace("\n", "\n\t", $code) . "\n\t";
				
				$new_c = trim( substr($line, $pos + 1) );
				if ($new_c) {
					$new_contents .= "\n" . $new_c;
				}
				
				$new_contents .= "\n" . implode("\n", array_slice($lines, $start_brackets_line) );
				
				$new_contents = str_replace("\n\n\n", "\n\n", str_replace("\t\n", "\n", $new_contents));
				return file_put_contents($file_path, $new_contents) > 0;
			}
		}
		
		return false;
	}*/";}s:25:"start_comments_line_index";i:2550;s:26:"start_comments_token_index";i:16900;s:23:"end_comments_line_index";i:2550;s:24:"end_comments_token_index";i:16900;s:22:"start_args_token_index";i:16909;s:20:"end_args_token_index";i:16921;s:9:"arguments";a:3:{s:10:"$file_path";N;s:18:"$function_settings";N;s:11:"$class_name";s:1:"0";}s:25:"start_brackets_line_index";i:2587;s:26:"start_brackets_token_index";i:16923;s:23:"end_brackets_line_index";i:2638;s:24:"end_brackets_token_index";i:17474;s:14:"end_line_index";i:2638;s:15:"end_token_index";i:17474;}s:14:"getClassString";a:20:{s:4:"name";s:14:"getClassString";s:16:"start_line_index";i:2712;s:17:"start_token_index";i:17482;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:3:{i:0;s:2354:"/* This is DEPRECATED bc if php is obfuscated this doesn't work.
	public static function addFunctionToFile($file_path, $function_settings, $class_name = 0) {
		$name = trim($function_settings["name"]);
		
		if ($file_path && $name) {
			//PREPARING FUNCTION STRING
			$str = self::getFunctionString($function_settings, $class_name);
			
			$code = $function_settings["code"];
			$code = $code ? ($class_name ? "\t\t" . str_replace("\n", "\n\t\t", $code) : str_replace("\n", "\n\t", $code)) : "";
			$str .= " {\n$code\n}\n";
			
			//SAVING FUNCTION STRING TO CLASS
			if ($class_name) {
				if (file_exists($file_path)) {
					$c = self::getClassFromFile($file_path, $class_name);
					$end_line = $c["end_line_index"];
					
					if (is_numeric($end_line)) {
						$contents = file_get_contents($file_path);
						$contents = str_replace("\r\n", "\n", $contents);
						$lines = explode("\n", $contents);
					
						//TODO: change this code to work with obfuscated php
						
						$new_contents = implode("\n", array_slice($lines, 0, $end_line - 1) );
					
						$line = $lines[ $end_line - 1 ];
						$pos = strpos($line, "}");
						$pos = $pos !== false ? $pos : 0;
					
						$new_c = trim(substr($line, 0, $pos));
						if ($new_c) 
							$new_contents .= "\n$new_c";
					
						$new_contents .= "\n\n$str";
					
						$new_c = trim(substr($line, $pos));
						if ($new_c) 
							$new_contents .= "\n$new_c";
					
						$new_contents .= "\n" . implode("\n", array_slice($lines, $end_line) );
					
						$new_contents = str_replace("\n\n\n", "\n\n", str_replace("\t\n", "\n", $new_contents));
						return file_put_contents($file_path, $new_contents) > 0;
					}
				}
			}
			//SAVING FUNCTION STRING AS A GENERIC FUNCTION
			else {
				if (file_exists($file_path)) {
					$contents = file_get_contents($file_path);
					$contents = str_replace("\r\n", "\n", $contents);
					$pos = strrpos($contents, "?>");
			
					if ($pos !== false) 
						$contents = substr($contents, 0, $pos) . "\n\n$str\n" . substr($contents, $pos);
					else 
						$contents .= (empty($contents) ? "<?php" : "\n") . "\n$str?>";
				}
				else 
					$contents = "<?php\n$str\n?>";
				
				$contents = str_replace("\n\n\n", "\n\n", str_replace("\t\n", "\n", $contents));
				return file_put_contents($file_path, $contents) > 0;
			}
		}
		
		return false;
	}*/";i:1;s:15:"/* END: ADDS */";i:2;s:18:"/* START: UTILS */";}s:25:"start_comments_line_index";i:2639;s:26:"start_comments_token_index";i:17476;s:23:"end_comments_line_index";i:2711;s:24:"end_comments_token_index";i:17480;s:22:"start_args_token_index";i:17489;s:20:"end_args_token_index";i:17491;s:9:"arguments";a:1:{s:15:"$class_settings";N;}s:25:"start_brackets_line_index";i:2712;s:26:"start_brackets_token_index";i:17493;s:23:"end_brackets_line_index";i:2787;s:24:"end_brackets_token_index";i:18362;s:14:"end_line_index";i:2787;s:15:"end_token_index";i:18362;}s:17:"getFunctionString";a:15:{s:4:"name";s:17:"getFunctionString";s:16:"start_line_index";i:2789;s:17:"start_token_index";i:18364;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:18371;s:20:"end_args_token_index";i:18380;s:9:"arguments";a:2:{s:18:"$function_settings";N;s:11:"$class_name";s:5:"false";}s:25:"start_brackets_line_index";i:2789;s:26:"start_brackets_token_index";i:18382;s:23:"end_brackets_line_index";i:2859;s:24:"end_brackets_token_index";i:19211;s:14:"end_line_index";i:2859;s:15:"end_token_index";i:19211;}s:22:"getClassPropertyString";a:15:{s:4:"name";s:22:"getClassPropertyString";s:16:"start_line_index";i:2861;s:17:"start_token_index";i:19213;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:19220;s:20:"end_args_token_index";i:19222;s:9:"arguments";a:1:{s:18:"$property_settings";N;}s:25:"start_brackets_line_index";i:2861;s:26:"start_brackets_token_index";i:19224;s:23:"end_brackets_line_index";i:2890;s:24:"end_brackets_token_index";i:19612;s:14:"end_line_index";i:2890;s:15:"end_token_index";i:19612;}}}}
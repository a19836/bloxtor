a:1:{s:44:"FileSystemServiceCacheRelatedServicesHandler";a:2:{s:7:"methods";a:9:{s:31:"addServiceToRelatedKeysToDelete";a:20:{s:4:"name";s:31:"addServiceToRelatedKeysToDelete";s:16:"start_line_index";i:23;s:17:"start_token_index";i:84;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:0;s:8:"comments";a:1:{i:0;s:464:"/*
	1. loop the $service_related_keys_to_delete array
	2. for each element get the related folder
		$dir_path = .../cache/.../select_item/PHP/__related/
	3. then call the getFilePathKey function to get the $file_path
	4. if the correspondent service does NOT exist yet, call the registerKey function and add a new record for the  in the service key.
	
	However only try to do this loop if the registrationStatus did NOT exceed the MAXIMUM_REGISTRATION_ATTEMPTS
	*/";}s:25:"start_comments_line_index";i:14;s:26:"start_comments_token_index";i:82;s:23:"end_comments_line_index";i:14;s:24:"end_comments_token_index";i:82;s:22:"start_args_token_index";i:89;s:20:"end_args_token_index";i:104;s:9:"arguments";a:4:{s:7:"$prefix";N;s:4:"$key";N;s:31:"$service_related_keys_to_delete";N;s:5:"$type";s:5:"false";}s:25:"start_brackets_line_index";i:23;s:26:"start_brackets_token_index";i:106;s:23:"end_brackets_line_index";i:64;s:24:"end_brackets_token_index";i:539;s:14:"end_line_index";i:64;s:15:"end_token_index";i:539;}s:6:"delete";a:20:{s:4:"name";s:6:"delete";s:16:"start_line_index";i:75;s:17:"start_token_index";i:543;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:0;s:8:"comments";a:1:{i:0;s:191:"/*
	$prefix = select_item
	$key = select_item_id-1_mysql 
	$type = PHP
	$key_type = PREFIX
	$original_key = select_item_id-
	
	$dir_path = .../cache/..../select_item/PHP/__related/prefix/
	*/";}s:25:"start_comments_line_index";i:66;s:26:"start_comments_token_index";i:541;s:23:"end_comments_line_index";i:66;s:24:"end_comments_token_index";i:541;s:22:"start_args_token_index";i:548;s:20:"end_args_token_index";i:562;s:9:"arguments";a:5:{s:7:"$prefix";N;s:4:"$key";N;s:5:"$type";N;s:9:"$key_type";N;s:13:"$original_key";N;}s:25:"start_brackets_line_index";i:75;s:26:"start_brackets_token_index";i:564;s:23:"end_brackets_line_index";i:79;s:24:"end_brackets_token_index";i:609;s:14:"end_line_index";i:79;s:15:"end_token_index";i:609;}s:25:"deleteRelatedServicesKeys";a:20:{s:4:"name";s:25:"deleteRelatedServicesKeys";s:16:"start_line_index";i:91;s:17:"start_token_index";i:613;s:4:"type";s:9:"protected";s:8:"abstract";b:0;s:6:"static";b:0;s:8:"comments";a:1:{i:0;s:547:"/*
	1. For each file inside of the $dir_path, cheks if it is a folder. If it is call the same function again, otherwise:
	2. gets the content of the file, unserialize it and loop the correspondent array.
	3. For each item:
		3.1 checks if the item "select_item_id-1_mysql" is IN each item, this is, checkIfKeyTypeMatchValue
		3.2 if it matches gets the item file path
		3.3  then delete the file for the item.
	
	 * TODO: create threads support. This means for each group of 5 files, launch a new thread and delete the correspondent services.
	 */";}s:25:"start_comments_line_index";i:81;s:26:"start_comments_token_index";i:611;s:23:"end_comments_line_index";i:81;s:24:"end_comments_token_index";i:611;s:22:"start_args_token_index";i:618;s:20:"end_args_token_index";i:632;s:9:"arguments";a:5:{s:7:"$prefix";N;s:4:"$key";N;s:5:"$type";N;s:9:"$key_type";N;s:9:"$dir_path";N;}s:25:"start_brackets_line_index";i:91;s:26:"start_brackets_token_index";i:634;s:23:"end_brackets_line_index";i:127;s:24:"end_brackets_token_index";i:962;s:14:"end_line_index";i:127;s:15:"end_token_index";i:962;}s:14:"getFilePathKey";a:20:{s:4:"name";s:14:"getFilePathKey";s:16:"start_line_index";i:139;s:17:"start_token_index";i:966;s:4:"type";s:9:"protected";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:453:"/*
	Based in a $dir_path, loops all the sub_files and for each,
		gets the content,
		unserialize the content
		and checks if the array already contains the $key item.
		If a file contains the key, return that file, otherwise returns an array with potential files where that $key can be inserted.
		
	However the files have a MAXIMUM_ITEMS_PER_FILE, which means that if a file already exceed that limit, the loop will try to find the next file.
	If 
	*/";}s:25:"start_comments_line_index";i:129;s:26:"start_comments_token_index";i:964;s:23:"end_comments_line_index";i:129;s:24:"end_comments_token_index";i:964;s:22:"start_args_token_index";i:973;s:20:"end_args_token_index";i:978;s:9:"arguments";a:2:{s:9:"$dir_path";N;s:4:"$key";N;}s:25:"start_brackets_line_index";i:139;s:26:"start_brackets_token_index";i:980;s:23:"end_brackets_line_index";i:170;s:24:"end_brackets_token_index";i:1290;s:14:"end_line_index";i:170;s:15:"end_token_index";i:1290;}s:11:"registerKey";a:20:{s:4:"name";s:11:"registerKey";s:16:"start_line_index";i:180;s:17:"start_token_index";i:1294;s:4:"type";s:9:"protected";s:8:"abstract";b:0;s:6:"static";b:0;s:8:"comments";a:1:{i:0;s:397:"/*
	Based in a list of files ($free_file_paths returned from the getFilePathKey function), loop this array and for each item:
		gets the content
		unserialize the content
		and if the array did NOT exceed the MAXIMUM_ITEMS_PER_FILE, add the $key to the array
		then save the array again to the file.
	If all the files already exceed the limit, creates a new file and adds the $key to the file.
	*/";}s:25:"start_comments_line_index";i:172;s:26:"start_comments_token_index";i:1292;s:23:"end_comments_line_index";i:172;s:24:"end_comments_token_index";i:1292;s:22:"start_args_token_index";i:1299;s:20:"end_args_token_index";i:1307;s:9:"arguments";a:3:{s:9:"$dir_path";N;s:4:"$key";N;s:16:"$free_file_paths";N;}s:25:"start_brackets_line_index";i:180;s:26:"start_brackets_token_index";i:1309;s:23:"end_brackets_line_index";i:264;s:24:"end_brackets_token_index";i:1899;s:14:"end_line_index";i:264;s:15:"end_token_index";i:1899;}s:22:"createServiceMainError";a:20:{s:4:"name";s:22:"createServiceMainError";s:16:"start_line_index";i:268;s:17:"start_token_index";i:1903;s:4:"type";s:9:"protected";s:8:"abstract";b:0;s:6:"static";b:0;s:8:"comments";a:1:{i:0;s:90:"/* ---------------------------------------- XX ---------------------------------------- */";}s:25:"start_comments_line_index";i:266;s:26:"start_comments_token_index";i:1901;s:23:"end_comments_line_index";i:266;s:24:"end_comments_token_index";i:1901;s:22:"start_args_token_index";i:1908;s:20:"end_args_token_index";i:1917;s:9:"arguments";a:2:{s:7:"$prefix";N;s:5:"$type";s:5:"false";}s:25:"start_brackets_line_index";i:268;s:26:"start_brackets_token_index";i:1919;s:23:"end_brackets_line_index";i:276;s:24:"end_brackets_token_index";i:1995;s:14:"end_line_index";i:276;s:15:"end_token_index";i:1995;}s:24:"setRegistrationKeyStatus";a:15:{s:4:"name";s:24:"setRegistrationKeyStatus";s:16:"start_line_index";i:278;s:17:"start_token_index";i:1997;s:4:"type";s:9:"protected";s:8:"abstract";b:0;s:6:"static";b:0;s:22:"start_args_token_index";i:2002;s:20:"end_args_token_index";i:2017;s:9:"arguments";a:4:{s:7:"$prefix";N;s:4:"$key";N;s:5:"$type";N;s:13:"$error_exists";s:5:"false";}s:25:"start_brackets_line_index";i:278;s:26:"start_brackets_token_index";i:2019;s:23:"end_brackets_line_index";i:289;s:24:"end_brackets_token_index";i:2147;s:14:"end_line_index";i:289;s:15:"end_token_index";i:2147;}s:24:"getRegistrationKeyStatus";a:15:{s:4:"name";s:24:"getRegistrationKeyStatus";s:16:"start_line_index";i:291;s:17:"start_token_index";i:2149;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:0;s:22:"start_args_token_index";i:2154;s:20:"end_args_token_index";i:2162;s:9:"arguments";a:3:{s:7:"$prefix";N;s:4:"$key";N;s:5:"$type";N;}s:25:"start_brackets_line_index";i:291;s:26:"start_brackets_token_index";i:2164;s:23:"end_brackets_line_index";i:299;s:24:"end_brackets_token_index";i:2234;s:14:"end_line_index";i:299;s:15:"end_token_index";i:2234;}s:32:"getRegistrationKeyStatusFilePath";a:15:{s:4:"name";s:32:"getRegistrationKeyStatusFilePath";s:16:"start_line_index";i:301;s:17:"start_token_index";i:2236;s:4:"type";s:9:"protected";s:8:"abstract";b:0;s:6:"static";b:0;s:22:"start_args_token_index";i:2241;s:20:"end_args_token_index";i:2249;s:9:"arguments";a:3:{s:7:"$prefix";N;s:4:"$key";N;s:5:"$type";N;}s:25:"start_brackets_line_index";i:301;s:26:"start_brackets_token_index";i:2251;s:23:"end_brackets_line_index";i:308;s:24:"end_brackets_token_index";i:2322;s:14:"end_line_index";i:308;s:15:"end_token_index";i:2322;}}s:5:"props";a:3:{s:29:"MAXIMUM_REGISTRATION_ATTEMPTS";a:16:{s:4:"name";s:29:"MAXIMUM_REGISTRATION_ATTEMPTS";s:4:"type";s:6:"public";s:5:"value";s:1:"5";s:8:"var_type";s:0:"";s:6:"static";b:0;s:8:"abstract";b:0;s:5:"const";b:1;s:16:"start_line_index";i:6;s:17:"start_token_index";i:29;s:14:"end_line_index";i:6;s:15:"end_token_index";i:36;s:8:"comments";a:1:{i:0;s:13:"/*protected*/";}s:25:"start_comments_line_index";i:6;s:26:"start_comments_token_index";i:27;s:23:"end_comments_line_index";i:6;s:24:"end_comments_token_index";i:27;}s:47:"RELATED_SERVICE_REGISTRATION_STATUS_FOLDER_NAME";a:16:{s:4:"name";s:47:"RELATED_SERVICE_REGISTRATION_STATUS_FOLDER_NAME";s:4:"type";s:6:"public";s:5:"value";s:10:""__status"";s:8:"var_type";s:6:"string";s:6:"static";b:0;s:8:"abstract";b:0;s:5:"const";b:1;s:16:"start_line_index";i:7;s:17:"start_token_index";i:40;s:14:"end_line_index";i:7;s:15:"end_token_index";i:47;s:8:"comments";a:1:{i:0;s:13:"/*protected*/";}s:25:"start_comments_line_index";i:7;s:26:"start_comments_token_index";i:38;s:23:"end_comments_line_index";i:7;s:24:"end_comments_token_index";i:38;}s:28:"SERVICE_MAIN_ERROR_FILE_NAME";a:16:{s:4:"name";s:28:"SERVICE_MAIN_ERROR_FILE_NAME";s:4:"type";s:6:"public";s:5:"value";s:9:""__error"";s:8:"var_type";s:6:"string";s:6:"static";b:0;s:8:"abstract";b:0;s:5:"const";b:1;s:16:"start_line_index";i:8;s:17:"start_token_index";i:51;s:14:"end_line_index";i:8;s:15:"end_token_index";i:58;s:8:"comments";a:1:{i:0;s:13:"/*protected*/";}s:25:"start_comments_line_index";i:8;s:26:"start_comments_token_index";i:49;s:23:"end_comments_line_index";i:8;s:24:"end_comments_token_index";i:49;}}}}
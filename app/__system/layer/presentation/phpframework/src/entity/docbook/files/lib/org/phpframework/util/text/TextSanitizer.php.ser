a:1:{s:13:"TextSanitizer";a:1:{s:7:"methods";a:22:{s:31:"convertBinaryCodeInTextToBase64";a:15:{s:4:"name";s:31:"convertBinaryCodeInTextToBase64";s:16:"start_line_index";i:4;s:17:"start_token_index";i:7;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:14;s:20:"end_args_token_index";i:16;s:9:"arguments";a:1:{s:5:"$text";N;}s:25:"start_brackets_line_index";i:4;s:26:"start_brackets_token_index";i:18;s:23:"end_brackets_line_index";i:46;s:24:"end_brackets_token_index";i:405;s:14:"end_line_index";i:46;s:15:"end_token_index";i:405;}s:16:"normalizeAccents";a:20:{s:4:"name";s:16:"normalizeAccents";s:16:"start_line_index";i:49;s:17:"start_token_index";i:409;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:71:"//copied from https://www.php.net/manual/pt_BR/normalizer.normalize.php";}s:25:"start_comments_line_index";i:48;s:26:"start_comments_token_index";i:407;s:23:"end_comments_line_index";i:48;s:24:"end_comments_token_index";i:407;s:22:"start_args_token_index";i:416;s:20:"end_args_token_index";i:418;s:9:"arguments";a:1:{s:2:"$s";N;}s:25:"start_brackets_line_index";i:49;s:26:"start_brackets_token_index";i:420;s:23:"end_brackets_line_index";i:116;s:24:"end_brackets_token_index";i:1322;s:14:"end_line_index";i:116;s:15:"end_token_index";i:1322;}s:55:"replaceEscapedEndLinesInsideOfPHPDoubleQuotesInHtmlCode";a:20:{s:4:"name";s:55:"replaceEscapedEndLinesInsideOfPHPDoubleQuotesInHtmlCode";s:16:"start_line_index";i:121;s:17:"start_token_index";i:1330;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:3:{i:0;s:85:"//replace \n inside of double quotes variables, bc prettyPrint escapes the end lines.";i:1;s:54:"//Note that $text is a html code with php code inside.";i:2;s:173:"//This method should be used in the code generated by the PhpParser\PrettyPrinter\Standard->prettyPrint($stmts); See an example in CMSFileHandler::setMethodParamsFromContent";}s:25:"start_comments_line_index";i:118;s:26:"start_comments_token_index";i:1324;s:23:"end_comments_line_index";i:120;s:24:"end_comments_token_index";i:1328;s:22:"start_args_token_index";i:1337;s:20:"end_args_token_index";i:1339;s:9:"arguments";a:1:{s:5:"$text";N;}s:25:"start_brackets_line_index";i:121;s:26:"start_brackets_token_index";i:1341;s:23:"end_brackets_line_index";i:166;s:24:"end_brackets_token_index";i:1788;s:14:"end_line_index";i:166;s:15:"end_token_index";i:1788;}s:19:"replaceIfNotEscaped";a:21:{s:4:"name";s:19:"replaceIfNotEscaped";s:16:"start_line_index";i:172;s:17:"start_token_index";i:1794;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:154:"//Used in this class and in lib/org/phpframework/workflow/task/programming/createform/WorkFlowTaskImpl.php and lib/org/phpframework/.../CMSFileHandler.php";}s:12:"doc_comments";a:1:{i:0;s:224:"/**
	* replaceIfNotEscaped: replaces a string inside of another string if not escaped, this is, repace $to_replace by $to_replacement in $text if $to_replace not escaped. Return the new string with the values replaced.
	*/";}s:25:"start_comments_line_index";i:168;s:26:"start_comments_token_index";i:1790;s:23:"end_comments_line_index";i:171;s:24:"end_comments_token_index";i:1792;s:22:"start_args_token_index";i:1801;s:20:"end_args_token_index";i:1809;s:9:"arguments";a:3:{s:11:"$to_replace";N;s:12:"$replacement";N;s:5:"$text";N;}s:25:"start_brackets_line_index";i:172;s:26:"start_brackets_token_index";i:1811;s:23:"end_brackets_line_index";i:201;s:24:"end_brackets_token_index";i:2041;s:14:"end_line_index";i:201;s:15:"end_token_index";i:2041;}s:13:"stripCSlashes";a:21:{s:4:"name";s:13:"stripCSlashes";s:16:"start_line_index";i:238;s:17:"start_token_index";i:2049;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:56:"//This method is deprecated bc is a little bit more slow";i:1;s:726:"/*public static function replaceIfNotEscapedOld($to_replace, $replacement, $text) {
		if ($text) {
			$new_text = "";
			$pos = 0;
			
			do {
				$start_pos = mb_strpos($text, $to_replace, $pos);
				
				if ($start_pos !== false) {
					$escaped = self::isMBSubstrCharEscaped($text, $start_pos);
					$next_pos = $start_pos + strlen($to_replace);
					
					if (!$escaped)
						$new_text .= mb_substr($text, $pos, $start_pos - $pos) . $replacement;
					else
						$new_text .= mb_substr($text, $pos, $next_pos - $pos);
					
					$pos = $next_pos;
				}
				else
					$new_text .= mb_substr($text, $pos);
			}
			while($start_pos !== false);
			
			return $new_text;
		}
		
		return $text;
	}*/";}s:12:"doc_comments";a:1:{i:0;s:432:"/**
	* stripCSlashes: strip all slashes for all characters inside of $chars
	* Note that the stripcslashes and stripslashes have a diferent behaviour. The stripcslashes removes slashes for double quotes and the stripslashes remove slashes for a bunch of escaped chars. 
	* This method only removes the slashes for a specific chars and if the chars are escaped, this is, if there is "\\'", this method won't remove any slash.
	*/";}s:25:"start_comments_line_index";i:202;s:26:"start_comments_token_index";i:2043;s:23:"end_comments_line_index";i:233;s:24:"end_comments_token_index";i:2047;s:22:"start_args_token_index";i:2056;s:20:"end_args_token_index";i:2061;s:9:"arguments";a:2:{s:5:"$text";N;s:6:"$chars";N;}s:25:"start_brackets_line_index";i:238;s:26:"start_brackets_token_index";i:2063;s:23:"end_brackets_line_index";i:253;s:24:"end_brackets_token_index";i:2190;s:14:"end_line_index";i:253;s:15:"end_token_index";i:2190;}s:16:"stripCharSlashes";a:20:{s:4:"name";s:16:"stripCharSlashes";s:16:"start_line_index";i:258;s:17:"start_token_index";i:2194;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:73:"/**
	* stripCharSlashes: strip all slashes for a specific character
	*/";}s:25:"start_comments_line_index";i:255;s:26:"start_comments_token_index";i:2192;s:23:"end_comments_line_index";i:255;s:24:"end_comments_token_index";i:2192;s:22:"start_args_token_index";i:2201;s:20:"end_args_token_index";i:2206;s:9:"arguments";a:2:{s:5:"$text";N;s:5:"$char";N;}s:25:"start_brackets_line_index";i:258;s:26:"start_brackets_token_index";i:2208;s:23:"end_brackets_line_index";i:273;s:24:"end_brackets_token_index";i:2348;s:14:"end_line_index";i:273;s:15:"end_token_index";i:2348;}s:23:"addCSlashesExcludingPTL";a:21:{s:4:"name";s:23:"addCSlashesExcludingPTL";s:16:"start_line_index";i:303;s:17:"start_token_index";i:2356;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:56:"//This method is deprecated bc is a little bit more slow";i:1;s:440:"/*public static function stripCharSlashesOld($text, $char) {
		$pos = 0;
		
		do {
			$pos = mb_strpos($text, $char, $pos);
			
			if ($pos !== false) {
				$prev = mb_substr($text, $pos - 1, 1);
				
				if ($prev == "\\" && !self::isMBSubstrCharEscaped($text, $pos - 1))
					$text = mb_substr($text, 0, $pos - 1) . mb_substr($text, $pos);
				else
					$pos++;
			}
		}
		while ($pos !== false);
		
		return $text;
	}*/";}s:12:"doc_comments";a:1:{i:0;s:440:"/**
	* addCSlashesExcludingPTL: add slashes to all characters inside of $chars but excluding the ptl instructions
	*	$text: is the html with ptl instructions
	* 	$chars are the chars to be escaped: like: '\\"'
	* 	$php_vars_control: check the addCharSlashesWithPHPVarsControl method
	*
	* In the future change this method to use the mbStrSplit method instead of the mb_substr, bc the mb_substr method is too slow for long strings
	*/";}s:25:"start_comments_line_index";i:274;s:26:"start_comments_token_index";i:2350;s:23:"end_comments_line_index";i:295;s:24:"end_comments_token_index";i:2354;s:22:"start_args_token_index";i:2363;s:20:"end_args_token_index";i:2375;s:9:"arguments";a:3:{s:5:"$text";N;s:6:"$chars";N;s:17:"$php_vars_control";s:4:"true";}s:25:"start_brackets_line_index";i:303;s:26:"start_brackets_token_index";i:2377;s:23:"end_brackets_line_index";i:354;s:24:"end_brackets_token_index";i:2938;s:14:"end_line_index";i:354;s:15:"end_token_index";i:2938;}s:11:"addCSlashes";a:21:{s:4:"name";s:11:"addCSlashes";s:16:"start_line_index";i:417;s:17:"start_token_index";i:2946;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:56:"//This method is deprecated bc is a little bit more slow";i:1;s:1819:"/*public static function addCSlashesExcludingPTLOld($text, $chars, $php_vars_control = true) {
		$length = mb_strlen($text);
		$new_text = "";
		$start_pos = $end_pos = 0;
		
		do {
			$pos_1 = mb_strpos($text, "<ptl:", $start_pos);
			$pos_2 = mb_strpos($text, "<php:", $start_pos);
			$pos_3 = mb_strpos($text, "<?:", $start_pos);
			$pos_4 = mb_strpos($text, "<?php:", $start_pos);
			
			$end_pos = $pos_1;
			
			if (!$end_pos || ($pos_2 && $end_pos > $pos_2))
				$end_pos = $pos_2;
			
			if (!$end_pos || ($pos_3 && $end_pos > $pos_3))
				$end_pos = $pos_3;
			
			if (!$end_pos || ($pos_4 && $end_pos > $pos_4))
				$end_pos = $pos_4;
			
			if ($end_pos !== false) {
				$str = mb_substr($text, $start_pos, $end_pos - $start_pos);
				$new_text .= self::addCSlashes($str, $chars, $php_vars_control); //add previous code of ptl tag
				$start_pos = $length;
				
				//find start pos
				$double_quotes_open = $single_quotes_open = false;
				for ($i = $end_pos + 1; $i < $length; $i++) {
					$c = mb_substr($text, $i, 1);
					
					if ($c == '"' && !$single_quotes_open && !self::isMBSubstrCharEscaped($text, $i))
						$double_quotes_open = !$double_quotes_open;
					else if ($c == "'" && !$double_quotes_open && !self::isMBSubstrCharEscaped($text, $i))
						$single_quotes_open = !$single_quotes_open;
					else if ($c == ">" && !$double_quotes_open && !$single_quotes_open) {
						$start_pos = $i + 1;
						break;
					}
				}
				
				$new_text .= mb_substr($text, $end_pos, $start_pos - $end_pos); //add ptl tag
			}
			else {
				$str = mb_substr($text, $start_pos);
				$new_text .= self::addCSlashes($str, $chars, $php_vars_control); //add last code or all code if no tpl tags
			}
		}
		while($end_pos !== false);
		
		return $new_text;
	}*/";}s:12:"doc_comments";a:1:{i:0;s:676:"/**
	* addCSlashes: add slashes to all characters inside of $chars
	* Note that the addcslashes and addslashes have a diferent behaviour. The addcslashes adds slashes for all double quotes even if they are escaped and the addslashes remove slashes for a bunch of escaped chars. 
	* This method only adds slashes for a specific chars and if the chars are escaped, this is, if there is "\'", this method will add a slash to "\" and another to "'", converting the code to "\\\'". But if there a code like "\\'", this method will convert it to: "\\\'". This means that this code is intelligent.
	*
	* 	$php_vars_control: check the addCharSlashesWithPHPVarsControl method
	*/";}s:25:"start_comments_line_index";i:355;s:26:"start_comments_token_index";i:2940;s:23:"end_comments_line_index";i:410;s:24:"end_comments_token_index";i:2944;s:22:"start_args_token_index";i:2953;s:20:"end_args_token_index";i:2965;s:9:"arguments";a:3:{s:5:"$text";N;s:6:"$chars";N;s:17:"$php_vars_control";s:5:"false";}s:25:"start_brackets_line_index";i:417;s:26:"start_brackets_token_index";i:2967;s:23:"end_brackets_line_index";i:437;s:24:"end_brackets_token_index";i:3126;s:14:"end_line_index";i:437;s:15:"end_token_index";i:3126;}s:14:"addCharSlashes";a:20:{s:4:"name";s:14:"addCharSlashes";s:16:"start_line_index";i:448;s:17:"start_token_index";i:3130;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:388:"/**
	* addCharSlashes: add slashes for a specific character
	*
	* 	$add_slash_to_escaped_char: 
	* 		if true, detects if the $char is escaped (this is if there is a slash before) and if it is, escapes the char and the previous slash that was escaping the $char
	* 		if false, simply escapes the $char
	*
	* 	$php_vars_control: check the addCharSlashesWithPHPVarsControl method
	*/";}s:25:"start_comments_line_index";i:439;s:26:"start_comments_token_index";i:3128;s:23:"end_comments_line_index";i:439;s:24:"end_comments_token_index";i:3128;s:22:"start_args_token_index";i:3137;s:20:"end_args_token_index";i:3156;s:9:"arguments";a:4:{s:5:"$text";N;s:5:"$char";N;s:26:"$add_slash_to_escaped_char";s:4:"true";s:17:"$php_vars_control";s:5:"false";}s:25:"start_brackets_line_index";i:448;s:26:"start_brackets_token_index";i:3158;s:23:"end_brackets_line_index";i:467;s:24:"end_brackets_token_index";i:3337;s:14:"end_line_index";i:467;s:15:"end_token_index";i:3337;}s:32:"addCharSlashesWithPHPVarsControl";a:21:{s:4:"name";s:32:"addCharSlashesWithPHPVarsControl";s:16:"start_line_index";i:511;s:17:"start_token_index";i:3345;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:121:"//This method is deprecated bc mb_substr is too slow. mb_substr should only be used if we don't change the $text it-self.";i:1;s:1005:"/*public static function addCharSlashesOld($text, $char, $add_slash_to_escaped_char = true, $php_vars_control = false) {
		if ($php_vars_control && (mb_strpos($text, '{$') !== false || mb_strpos($text, '${') !== false))
			return self::addCharSlashesWithPHPVarsControl($text, $char, $add_slash_to_escaped_char);
		
		$pos = 0;
		
		do {
			$pos = mb_strpos($text, $char, $pos);
			
			if ($pos !== false) {
				if ($add_slash_to_escaped_char && self::isMBSubstrCharEscaped($text, $pos)) {
					$text = mb_substr($text, 0, $pos) . "\\\\" . mb_substr($text, $pos); //adds 2 slashes: one for the existent slash that escapes the $char, and another adds a 2nd slash to the $char
					$pos += 3; //move $pos to the next position after $char
				}
				else {
					$text = mb_substr($text, 0, $pos) . "\\" . mb_substr($text, $pos); //only adds 1 slash to the $char
					$pos += 2; //move $pos to the next position after $char
				}
			}
		}
		while ($pos !== false);
		
		return $text;
	}*/";}s:12:"doc_comments";a:1:{i:0;s:1115:"/**
	* addCharSlashesWithPHPVarsControl: add slashes for a specific character but only in the text outside of the php vars like ${...} or {$...}
	*
	* 	This is, checks if exists any '{$' or '${' and if yes, doesn't escapes anything inside of the brackets, bc it is a php var that should not be touched.
	* 		example: 
	*			'"' . self::addCharSlashes('this is a simple phrase with double quotes " and the var {$person["name"]}!', '"') . '"'
	*
	* 		When addCharSlashesWithPHPVarsControl is called, then the it will return:
	*			'"this is a simple phrase with double quotes \" and the var {$person["name"]}!"'
	* 		When addCharSlashes is called, then the it will return:
	*			'"this is a simple phrase with double quotes \" and the var {$person[\"name\"]}!"'
	*			...which will return a php error, bc what is inside of {$...} will be executed first in php!
	*
	* 	$add_slash_to_escaped_char: 
	* 		if true, detects if the $char is escaped (this is if there is a slash before) and if it is, escapes the char and the previous slash that was escaping the $char
	* 		if false, simply escapes the $char
	*/";}s:25:"start_comments_line_index";i:468;s:26:"start_comments_token_index";i:3339;s:23:"end_comments_line_index";i:494;s:24:"end_comments_token_index";i:3343;s:22:"start_args_token_index";i:3352;s:20:"end_args_token_index";i:3371;s:9:"arguments";a:4:{s:5:"$text";N;s:5:"$char";N;s:26:"$add_slash_to_escaped_char";s:4:"true";s:11:"$text_chars";s:4:"null";}s:25:"start_brackets_line_index";i:511;s:26:"start_brackets_token_index";i:3373;s:23:"end_brackets_line_index";i:539;s:24:"end_brackets_token_index";i:3631;s:14:"end_line_index";i:539;s:15:"end_token_index";i:3631;}s:10:"mbStrSplit";a:21:{s:4:"name";s:10:"mbStrSplit";s:16:"start_line_index";i:578;s:17:"start_token_index";i:3639;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:121:"//This method is deprecated bc mb_substr is too slow. mb_substr should only be used if we don't change the $text it-self.";i:1;s:1452:"/*public static function addCharSlashesWithPHPVarsControlOld($text, $char, $add_slash_to_escaped_char = true) {
		//error_log("addCharSlashesWithPHPVarsControl(\$text, $char, $add_slash_to_escaped_char\n\n", 3, "/var/www/html/livingroop/default/tmp/test.log");
		
		$l = mb_strlen($text);
		$is_var = 0;
		//error_log("length:$l|".strlen($text)."\n\n", 3, "/var/www/html/livingroop/default/tmp/test.log");
		
		for ($i = 0; $i < $l; $i++) {
			$c = mb_substr($text, $i, 1);
			
			if ($c == '$' && (mb_substr($text, $i - 1, 1) == "{" || mb_substr($text, $i + 1, 1) == "{") && !self::isMBSubstrCharEscaped($text, $i)) //{$...} or ${...}
				$is_var++;
			else if ($is_var && $c == "}")
				$is_var--;
			else if (!$is_var && $c == $char) {
				if ($add_slash_to_escaped_char && self::isMBSubstrCharEscaped($text, $i)) {
					$text = mb_substr($text, 0, $i) . "\\\\" . mb_substr($text, $i); //adds 2 slashes: one for the existent slash that escapes the $char, and another adds a 2nd slash to the $char
					$i += 2; //move $pos to the new $char position
					$l += 2; //increase 2 char to length
				}
				else {
					$text = mb_substr($text, 0, $i) . "\\" . mb_substr($text, $i); //only adds 1 slash to the $char
					$i += 1; //move $pos to the new $char position
					$l += 1; //increase 1 char to length
				}
			}
		}
		//error_log("END\n\n", 3, "/var/www/html/livingroop/default/tmp/test.log");
		
		return $text;
	}*/";}s:12:"doc_comments";a:1:{i:0;s:251:"/**
	* mbStrSplit: returns the multibyte character list of a string. 
	* This function splits a multibyte string into an array of characters. Comparable to str_split().
	* A (simpler) way to extract all characters from a UTF-8 string to array.
	*/";}s:25:"start_comments_line_index";i:540;s:26:"start_comments_token_index";i:3633;s:23:"end_comments_line_index";i:573;s:24:"end_comments_token_index";i:3637;s:22:"start_args_token_index";i:3646;s:20:"end_args_token_index";i:3648;s:9:"arguments";a:1:{s:4:"$str";N;}s:25:"start_brackets_line_index";i:578;s:26:"start_brackets_token_index";i:3650;s:23:"end_brackets_line_index";i:582;s:24:"end_brackets_token_index";i:3687;s:14:"end_line_index";i:582;s:15:"end_token_index";i:3687;}s:13:"isCharEscaped";a:20:{s:4:"name";s:13:"isCharEscaped";s:16:"start_line_index";i:587;s:17:"start_token_index";i:3691;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:75:"/**
	* isCharEscaped: checks if a char is escaped given its position 
	*/";}s:25:"start_comments_line_index";i:584;s:26:"start_comments_token_index";i:3689;s:23:"end_comments_line_index";i:584;s:24:"end_comments_token_index";i:3689;s:22:"start_args_token_index";i:3698;s:20:"end_args_token_index";i:3703;s:9:"arguments";a:2:{s:4:"$str";N;s:6:"$index";N;}s:25:"start_brackets_line_index";i:587;s:26:"start_brackets_token_index";i:3705;s:23:"end_brackets_line_index";i:601;s:24:"end_brackets_token_index";i:3793;s:14:"end_line_index";i:601;s:15:"end_token_index";i:3793;}s:15:"isMBCharEscaped";a:20:{s:4:"name";s:15:"isMBCharEscaped";s:16:"start_line_index";i:606;s:17:"start_token_index";i:3797;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:75:"/**
	* isCharEscaped: checks if a char is escaped given its position 
	*/";}s:25:"start_comments_line_index";i:603;s:26:"start_comments_token_index";i:3795;s:23:"end_comments_line_index";i:603;s:24:"end_comments_token_index";i:3795;s:22:"start_args_token_index";i:3804;s:20:"end_args_token_index";i:3816;s:9:"arguments";a:3:{s:4:"$str";N;s:6:"$index";N;s:11:"$text_chars";s:4:"null";}s:25:"start_brackets_line_index";i:606;s:26:"start_brackets_token_index";i:3818;s:23:"end_brackets_line_index";i:618;s:24:"end_brackets_token_index";i:3907;s:14:"end_line_index";i:618;s:15:"end_token_index";i:3907;}s:21:"isMBSubstrCharEscaped";a:20:{s:4:"name";s:21:"isMBSubstrCharEscaped";s:16:"start_line_index";i:623;s:17:"start_token_index";i:3911;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:118:"/**
	* isMBSubstrCharEscaped: checks if a char is escaped given its position based in the mb_substr php function
	*/";}s:25:"start_comments_line_index";i:620;s:26:"start_comments_token_index";i:3909;s:23:"end_comments_line_index";i:620;s:24:"end_comments_token_index";i:3909;s:22:"start_args_token_index";i:3918;s:20:"end_args_token_index";i:3923;s:9:"arguments";a:2:{s:4:"$str";N;s:6:"$index";N;}s:25:"start_brackets_line_index";i:623;s:26:"start_brackets_token_index";i:3925;s:23:"end_brackets_line_index";i:634;s:24:"end_brackets_token_index";i:4000;s:14:"end_line_index";i:634;s:15:"end_token_index";i:4000;}s:9:"isBadWord";a:20:{s:4:"name";s:9:"isBadWord";s:16:"start_line_index";i:639;s:17:"start_token_index";i:4004;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:59:"/**
	* isBadWord: verifies if a string is a bad word.
	*/";}s:25:"start_comments_line_index";i:636;s:26:"start_comments_token_index";i:4002;s:23:"end_comments_line_index";i:636;s:24:"end_comments_token_index";i:4002;s:22:"start_args_token_index";i:4011;s:20:"end_args_token_index";i:4013;s:9:"arguments";a:1:{s:7:"$string";N;}s:25:"start_brackets_line_index";i:639;s:26:"start_brackets_token_index";i:4015;s:23:"end_brackets_line_index";i:647;s:24:"end_brackets_token_index";i:4062;s:14:"end_line_index";i:647;s:15:"end_token_index";i:4062;}s:15:"replaceBadWords";a:20:{s:4:"name";s:15:"replaceBadWords";s:16:"start_line_index";i:652;s:17:"start_token_index";i:4066;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:64:"/**
	* replaceBadWords: replaces bad words with nicer ones
	*/";}s:25:"start_comments_line_index";i:649;s:26:"start_comments_token_index";i:4064;s:23:"end_comments_line_index";i:649;s:24:"end_comments_token_index";i:4064;s:22:"start_args_token_index";i:4073;s:20:"end_args_token_index";i:4075;s:9:"arguments";a:1:{s:7:"$string";N;}s:25:"start_brackets_line_index";i:652;s:26:"start_brackets_token_index";i:4077;s:23:"end_brackets_line_index";i:659;s:24:"end_brackets_token_index";i:4124;s:14:"end_line_index";i:659;s:15:"end_token_index";i:4124;}s:15:"replaceWebLinks";a:20:{s:4:"name";s:15:"replaceWebLinks";s:16:"start_line_index";i:664;s:17:"start_token_index";i:4128;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:48:"/**
	* replaceWebLinks: replaces web links
	*/";}s:25:"start_comments_line_index";i:661;s:26:"start_comments_token_index";i:4126;s:23:"end_comments_line_index";i:661;s:24:"end_comments_token_index";i:4126;s:22:"start_args_token_index";i:4135;s:20:"end_args_token_index";i:4144;s:9:"arguments";a:2:{s:7:"$string";N;s:12:"$replacement";s:2:"""";}s:25:"start_brackets_line_index";i:664;s:26:"start_brackets_token_index";i:4146;s:23:"end_brackets_line_index";i:697;s:24:"end_brackets_token_index";i:4382;s:14:"end_line_index";i:697;s:15:"end_token_index";i:4382;}s:14:"breakLongWords";a:20:{s:4:"name";s:14:"breakLongWords";s:16:"start_line_index";i:702;s:17:"start_token_index";i:4386;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:46:"/**
	* breakLongWords: breaks long words
	*/";}s:25:"start_comments_line_index";i:699;s:26:"start_comments_token_index";i:4384;s:23:"end_comments_line_index";i:699;s:24:"end_comments_token_index";i:4384;s:22:"start_args_token_index";i:4393;s:20:"end_args_token_index";i:4409;s:9:"arguments";a:3:{s:7:"$string";N;s:10:"$maxLength";s:2:"20";s:5:"$html";s:5:"false";}s:25:"start_brackets_line_index";i:702;s:26:"start_brackets_token_index";i:4411;s:23:"end_brackets_line_index";i:706;s:24:"end_brackets_token_index";i:4459;s:14:"end_line_index";i:706;s:15:"end_token_index";i:4459;}s:18:"breakLongTextWords";a:20:{s:4:"name";s:18:"breakLongTextWords";s:16:"start_line_index";i:711;s:17:"start_token_index";i:4463;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:55:"/**
	* breakLongTextWords: breaks long text words
	*/";}s:25:"start_comments_line_index";i:708;s:26:"start_comments_token_index";i:4461;s:23:"end_comments_line_index";i:708;s:24:"end_comments_token_index";i:4461;s:22:"start_args_token_index";i:4470;s:20:"end_args_token_index";i:4479;s:9:"arguments";a:2:{s:7:"$string";N;s:10:"$maxLength";s:2:"20";}s:25:"start_brackets_line_index";i:711;s:26:"start_brackets_token_index";i:4481;s:23:"end_brackets_line_index";i:729;s:24:"end_brackets_token_index";i:4625;s:14:"end_line_index";i:729;s:15:"end_token_index";i:4625;}s:18:"breakLongHtmlWords";a:20:{s:4:"name";s:18:"breakLongHtmlWords";s:16:"start_line_index";i:734;s:17:"start_token_index";i:4629;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:55:"/**
	* breakLongHtmlWords: breaks long html words
	*/";}s:25:"start_comments_line_index";i:731;s:26:"start_comments_token_index";i:4627;s:23:"end_comments_line_index";i:731;s:24:"end_comments_token_index";i:4627;s:22:"start_args_token_index";i:4636;s:20:"end_args_token_index";i:4652;s:9:"arguments";a:3:{s:4:"$str";N;s:10:"$maxLength";s:2:"20";s:5:"$char";s:3:"" "";}s:25:"start_brackets_line_index";i:734;s:26:"start_brackets_token_index";i:4653;s:23:"end_brackets_line_index";i:770;s:24:"end_brackets_token_index";i:4896;s:14:"end_line_index";i:770;s:15:"end_token_index";i:4896;}s:14:"sanitizeString";a:20:{s:4:"name";s:14:"sanitizeString";s:16:"start_line_index";i:775;s:17:"start_token_index";i:4900;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:29:"/**
	* sanitizeString: 
	*/";}s:25:"start_comments_line_index";i:772;s:26:"start_comments_token_index";i:4898;s:23:"end_comments_line_index";i:772;s:24:"end_comments_token_index";i:4898;s:22:"start_args_token_index";i:4907;s:20:"end_args_token_index";i:4916;s:9:"arguments";a:2:{s:7:"$string";N;s:5:"$html";s:5:"false";}s:25:"start_brackets_line_index";i:775;s:26:"start_brackets_token_index";i:4918;s:23:"end_brackets_line_index";i:783;s:24:"end_brackets_token_index";i:4977;s:14:"end_line_index";i:783;s:15:"end_token_index";i:4977;}s:12:"sanitizeText";a:20:{s:4:"name";s:12:"sanitizeText";s:16:"start_line_index";i:788;s:17:"start_token_index";i:4981;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:27:"/**
	* sanitizeText: 
	*/";}s:25:"start_comments_line_index";i:785;s:26:"start_comments_token_index";i:4979;s:23:"end_comments_line_index";i:785;s:24:"end_comments_token_index";i:4979;s:22:"start_args_token_index";i:4988;s:20:"end_args_token_index";i:4997;s:9:"arguments";a:2:{s:7:"$string";N;s:5:"$html";s:5:"false";}s:25:"start_brackets_line_index";i:788;s:26:"start_brackets_token_index";i:4999;s:23:"end_brackets_line_index";i:807;s:24:"end_brackets_token_index";i:5172;s:14:"end_line_index";i:807;s:15:"end_token_index";i:5172;}}}}
a:1:{s:13:"TextSanitizer";a:1:{s:7:"methods";a:22:{s:31:"convertBinaryCodeInTextToBase64";a:20:{s:4:"name";s:31:"convertBinaryCodeInTextToBase64";s:16:"start_line_index";i:5;s:17:"start_token_index";i:9;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:115:"//in case you have normal text mixed with binary code, then this function converts only the binary chras to base64.";}s:25:"start_comments_line_index";i:4;s:26:"start_comments_token_index";i:7;s:23:"end_comments_line_index";i:4;s:24:"end_comments_token_index";i:7;s:22:"start_args_token_index";i:16;s:20:"end_args_token_index";i:18;s:9:"arguments";a:1:{s:5:"$text";N;}s:25:"start_brackets_line_index";i:5;s:26:"start_brackets_token_index";i:20;s:23:"end_brackets_line_index";i:47;s:24:"end_brackets_token_index";i:407;s:14:"end_line_index";i:47;s:15:"end_token_index";i:407;}s:16:"normalizeAccents";a:20:{s:4:"name";s:16:"normalizeAccents";s:16:"start_line_index";i:51;s:17:"start_token_index";i:413;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:71:"//copied from https://www.php.net/manual/pt_BR/normalizer.normalize.php";i:1;s:81:"//remove accents and replace them by the correspondent character without accents.";}s:25:"start_comments_line_index";i:49;s:26:"start_comments_token_index";i:409;s:23:"end_comments_line_index";i:50;s:24:"end_comments_token_index";i:411;s:22:"start_args_token_index";i:420;s:20:"end_args_token_index";i:422;s:9:"arguments";a:1:{s:2:"$s";N;}s:25:"start_brackets_line_index";i:51;s:26:"start_brackets_token_index";i:424;s:23:"end_brackets_line_index";i:118;s:24:"end_brackets_token_index";i:1326;s:14:"end_line_index";i:118;s:15:"end_token_index";i:1326;}s:55:"replaceEscapedEndLinesInsideOfPHPDoubleQuotesInHtmlCode";a:20:{s:4:"name";s:55:"replaceEscapedEndLinesInsideOfPHPDoubleQuotesInHtmlCode";s:16:"start_line_index";i:123;s:17:"start_token_index";i:1334;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:3:{i:0;s:85:"//replace \n inside of double quotes variables, bc prettyPrint escapes the end lines.";i:1;s:54:"//Note that $text is a html code with php code inside.";i:2;s:173:"//This method should be used in the code generated by the PhpParser\PrettyPrinter\Standard->prettyPrint($stmts); See an example in CMSFileHandler::setMethodParamsFromContent";}s:25:"start_comments_line_index";i:120;s:26:"start_comments_token_index";i:1328;s:23:"end_comments_line_index";i:122;s:24:"end_comments_token_index";i:1332;s:22:"start_args_token_index";i:1341;s:20:"end_args_token_index";i:1343;s:9:"arguments";a:1:{s:5:"$text";N;}s:25:"start_brackets_line_index";i:123;s:26:"start_brackets_token_index";i:1345;s:23:"end_brackets_line_index";i:168;s:24:"end_brackets_token_index";i:1792;s:14:"end_line_index";i:168;s:15:"end_token_index";i:1792;}s:19:"replaceIfNotEscaped";a:21:{s:4:"name";s:19:"replaceIfNotEscaped";s:16:"start_line_index";i:174;s:17:"start_token_index";i:1798;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:154:"//Used in this class and in lib/org/phpframework/workflow/task/programming/createform/WorkFlowTaskImpl.php and lib/org/phpframework/.../CMSFileHandler.php";}s:12:"doc_comments";a:1:{i:0;s:224:"/**
	* replaceIfNotEscaped: replaces a string inside of another string if not escaped, this is, repace $to_replace by $to_replacement in $text if $to_replace not escaped. Return the new string with the values replaced.
	*/";}s:25:"start_comments_line_index";i:170;s:26:"start_comments_token_index";i:1794;s:23:"end_comments_line_index";i:173;s:24:"end_comments_token_index";i:1796;s:22:"start_args_token_index";i:1805;s:20:"end_args_token_index";i:1813;s:9:"arguments";a:3:{s:11:"$to_replace";N;s:12:"$replacement";N;s:5:"$text";N;}s:25:"start_brackets_line_index";i:174;s:26:"start_brackets_token_index";i:1815;s:23:"end_brackets_line_index";i:203;s:24:"end_brackets_token_index";i:2045;s:14:"end_line_index";i:203;s:15:"end_token_index";i:2045;}s:13:"stripCSlashes";a:21:{s:4:"name";s:13:"stripCSlashes";s:16:"start_line_index";i:240;s:17:"start_token_index";i:2053;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:56:"//This method is deprecated bc is a little bit more slow";i:1;s:726:"/*public static function replaceIfNotEscapedOld($to_replace, $replacement, $text) {
		if ($text) {
			$new_text = "";
			$pos = 0;
			
			do {
				$start_pos = mb_strpos($text, $to_replace, $pos);
				
				if ($start_pos !== false) {
					$escaped = self::isMBSubstrCharEscaped($text, $start_pos);
					$next_pos = $start_pos + strlen($to_replace);
					
					if (!$escaped)
						$new_text .= mb_substr($text, $pos, $start_pos - $pos) . $replacement;
					else
						$new_text .= mb_substr($text, $pos, $next_pos - $pos);
					
					$pos = $next_pos;
				}
				else
					$new_text .= mb_substr($text, $pos);
			}
			while($start_pos !== false);
			
			return $new_text;
		}
		
		return $text;
	}*/";}s:12:"doc_comments";a:1:{i:0;s:432:"/**
	* stripCSlashes: strip all slashes for all characters inside of $chars
	* Note that the stripcslashes and stripslashes have a diferent behaviour. The stripcslashes removes slashes for double quotes and the stripslashes remove slashes for a bunch of escaped chars. 
	* This method only removes the slashes for a specific chars and if the chars are escaped, this is, if there is "\\'", this method won't remove any slash.
	*/";}s:25:"start_comments_line_index";i:204;s:26:"start_comments_token_index";i:2047;s:23:"end_comments_line_index";i:235;s:24:"end_comments_token_index";i:2051;s:22:"start_args_token_index";i:2060;s:20:"end_args_token_index";i:2065;s:9:"arguments";a:2:{s:5:"$text";N;s:6:"$chars";N;}s:25:"start_brackets_line_index";i:240;s:26:"start_brackets_token_index";i:2067;s:23:"end_brackets_line_index";i:255;s:24:"end_brackets_token_index";i:2194;s:14:"end_line_index";i:255;s:15:"end_token_index";i:2194;}s:16:"stripCharSlashes";a:20:{s:4:"name";s:16:"stripCharSlashes";s:16:"start_line_index";i:260;s:17:"start_token_index";i:2198;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:73:"/**
	* stripCharSlashes: strip all slashes for a specific character
	*/";}s:25:"start_comments_line_index";i:257;s:26:"start_comments_token_index";i:2196;s:23:"end_comments_line_index";i:257;s:24:"end_comments_token_index";i:2196;s:22:"start_args_token_index";i:2205;s:20:"end_args_token_index";i:2210;s:9:"arguments";a:2:{s:5:"$text";N;s:5:"$char";N;}s:25:"start_brackets_line_index";i:260;s:26:"start_brackets_token_index";i:2212;s:23:"end_brackets_line_index";i:275;s:24:"end_brackets_token_index";i:2352;s:14:"end_line_index";i:275;s:15:"end_token_index";i:2352;}s:23:"addCSlashesExcludingPTL";a:21:{s:4:"name";s:23:"addCSlashesExcludingPTL";s:16:"start_line_index";i:305;s:17:"start_token_index";i:2360;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:56:"//This method is deprecated bc is a little bit more slow";i:1;s:440:"/*public static function stripCharSlashesOld($text, $char) {
		$pos = 0;
		
		do {
			$pos = mb_strpos($text, $char, $pos);
			
			if ($pos !== false) {
				$prev = mb_substr($text, $pos - 1, 1);
				
				if ($prev == "\\" && !self::isMBSubstrCharEscaped($text, $pos - 1))
					$text = mb_substr($text, 0, $pos - 1) . mb_substr($text, $pos);
				else
					$pos++;
			}
		}
		while ($pos !== false);
		
		return $text;
	}*/";}s:12:"doc_comments";a:1:{i:0;s:440:"/**
	* addCSlashesExcludingPTL: add slashes to all characters inside of $chars but excluding the ptl instructions
	*	$text: is the html with ptl instructions
	* 	$chars are the chars to be escaped: like: '\\"'
	* 	$php_vars_control: check the addCharSlashesWithPHPVarsControl method
	*
	* In the future change this method to use the mbStrSplit method instead of the mb_substr, bc the mb_substr method is too slow for long strings
	*/";}s:25:"start_comments_line_index";i:276;s:26:"start_comments_token_index";i:2354;s:23:"end_comments_line_index";i:297;s:24:"end_comments_token_index";i:2358;s:22:"start_args_token_index";i:2367;s:20:"end_args_token_index";i:2379;s:9:"arguments";a:3:{s:5:"$text";N;s:6:"$chars";N;s:17:"$php_vars_control";s:4:"true";}s:25:"start_brackets_line_index";i:305;s:26:"start_brackets_token_index";i:2381;s:23:"end_brackets_line_index";i:356;s:24:"end_brackets_token_index";i:2942;s:14:"end_line_index";i:356;s:15:"end_token_index";i:2942;}s:11:"addCSlashes";a:21:{s:4:"name";s:11:"addCSlashes";s:16:"start_line_index";i:419;s:17:"start_token_index";i:2950;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:56:"//This method is deprecated bc is a little bit more slow";i:1;s:1819:"/*public static function addCSlashesExcludingPTLOld($text, $chars, $php_vars_control = true) {
		$length = mb_strlen($text);
		$new_text = "";
		$start_pos = $end_pos = 0;
		
		do {
			$pos_1 = mb_strpos($text, "<ptl:", $start_pos);
			$pos_2 = mb_strpos($text, "<php:", $start_pos);
			$pos_3 = mb_strpos($text, "<?:", $start_pos);
			$pos_4 = mb_strpos($text, "<?php:", $start_pos);
			
			$end_pos = $pos_1;
			
			if (!$end_pos || ($pos_2 && $end_pos > $pos_2))
				$end_pos = $pos_2;
			
			if (!$end_pos || ($pos_3 && $end_pos > $pos_3))
				$end_pos = $pos_3;
			
			if (!$end_pos || ($pos_4 && $end_pos > $pos_4))
				$end_pos = $pos_4;
			
			if ($end_pos !== false) {
				$str = mb_substr($text, $start_pos, $end_pos - $start_pos);
				$new_text .= self::addCSlashes($str, $chars, $php_vars_control); //add previous code of ptl tag
				$start_pos = $length;
				
				//find start pos
				$double_quotes_open = $single_quotes_open = false;
				for ($i = $end_pos + 1; $i < $length; $i++) {
					$c = mb_substr($text, $i, 1);
					
					if ($c == '"' && !$single_quotes_open && !self::isMBSubstrCharEscaped($text, $i))
						$double_quotes_open = !$double_quotes_open;
					else if ($c == "'" && !$double_quotes_open && !self::isMBSubstrCharEscaped($text, $i))
						$single_quotes_open = !$single_quotes_open;
					else if ($c == ">" && !$double_quotes_open && !$single_quotes_open) {
						$start_pos = $i + 1;
						break;
					}
				}
				
				$new_text .= mb_substr($text, $end_pos, $start_pos - $end_pos); //add ptl tag
			}
			else {
				$str = mb_substr($text, $start_pos);
				$new_text .= self::addCSlashes($str, $chars, $php_vars_control); //add last code or all code if no tpl tags
			}
		}
		while($end_pos !== false);
		
		return $new_text;
	}*/";}s:12:"doc_comments";a:1:{i:0;s:676:"/**
	* addCSlashes: add slashes to all characters inside of $chars
	* Note that the addcslashes and addslashes have a diferent behaviour. The addcslashes adds slashes for all double quotes even if they are escaped and the addslashes remove slashes for a bunch of escaped chars. 
	* This method only adds slashes for a specific chars and if the chars are escaped, this is, if there is "\'", this method will add a slash to "\" and another to "'", converting the code to "\\\'". But if there a code like "\\'", this method will convert it to: "\\\'". This means that this code is intelligent.
	*
	* 	$php_vars_control: check the addCharSlashesWithPHPVarsControl method
	*/";}s:25:"start_comments_line_index";i:357;s:26:"start_comments_token_index";i:2944;s:23:"end_comments_line_index";i:412;s:24:"end_comments_token_index";i:2948;s:22:"start_args_token_index";i:2957;s:20:"end_args_token_index";i:2969;s:9:"arguments";a:3:{s:5:"$text";N;s:6:"$chars";N;s:17:"$php_vars_control";s:5:"false";}s:25:"start_brackets_line_index";i:419;s:26:"start_brackets_token_index";i:2971;s:23:"end_brackets_line_index";i:439;s:24:"end_brackets_token_index";i:3130;s:14:"end_line_index";i:439;s:15:"end_token_index";i:3130;}s:14:"addCharSlashes";a:20:{s:4:"name";s:14:"addCharSlashes";s:16:"start_line_index";i:450;s:17:"start_token_index";i:3134;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:388:"/**
	* addCharSlashes: add slashes for a specific character
	*
	* 	$add_slash_to_escaped_char: 
	* 		if true, detects if the $char is escaped (this is if there is a slash before) and if it is, escapes the char and the previous slash that was escaping the $char
	* 		if false, simply escapes the $char
	*
	* 	$php_vars_control: check the addCharSlashesWithPHPVarsControl method
	*/";}s:25:"start_comments_line_index";i:441;s:26:"start_comments_token_index";i:3132;s:23:"end_comments_line_index";i:441;s:24:"end_comments_token_index";i:3132;s:22:"start_args_token_index";i:3141;s:20:"end_args_token_index";i:3160;s:9:"arguments";a:4:{s:5:"$text";N;s:5:"$char";N;s:26:"$add_slash_to_escaped_char";s:4:"true";s:17:"$php_vars_control";s:5:"false";}s:25:"start_brackets_line_index";i:450;s:26:"start_brackets_token_index";i:3162;s:23:"end_brackets_line_index";i:469;s:24:"end_brackets_token_index";i:3341;s:14:"end_line_index";i:469;s:15:"end_token_index";i:3341;}s:32:"addCharSlashesWithPHPVarsControl";a:21:{s:4:"name";s:32:"addCharSlashesWithPHPVarsControl";s:16:"start_line_index";i:513;s:17:"start_token_index";i:3349;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:121:"//This method is deprecated bc mb_substr is too slow. mb_substr should only be used if we don't change the $text it-self.";i:1;s:1005:"/*public static function addCharSlashesOld($text, $char, $add_slash_to_escaped_char = true, $php_vars_control = false) {
		if ($php_vars_control && (mb_strpos($text, '{$') !== false || mb_strpos($text, '${') !== false))
			return self::addCharSlashesWithPHPVarsControl($text, $char, $add_slash_to_escaped_char);
		
		$pos = 0;
		
		do {
			$pos = mb_strpos($text, $char, $pos);
			
			if ($pos !== false) {
				if ($add_slash_to_escaped_char && self::isMBSubstrCharEscaped($text, $pos)) {
					$text = mb_substr($text, 0, $pos) . "\\\\" . mb_substr($text, $pos); //adds 2 slashes: one for the existent slash that escapes the $char, and another adds a 2nd slash to the $char
					$pos += 3; //move $pos to the next position after $char
				}
				else {
					$text = mb_substr($text, 0, $pos) . "\\" . mb_substr($text, $pos); //only adds 1 slash to the $char
					$pos += 2; //move $pos to the next position after $char
				}
			}
		}
		while ($pos !== false);
		
		return $text;
	}*/";}s:12:"doc_comments";a:1:{i:0;s:1115:"/**
	* addCharSlashesWithPHPVarsControl: add slashes for a specific character but only in the text outside of the php vars like ${...} or {$...}
	*
	* 	This is, checks if exists any '{$' or '${' and if yes, doesn't escapes anything inside of the brackets, bc it is a php var that should not be touched.
	* 		example: 
	*			'"' . self::addCharSlashes('this is a simple phrase with double quotes " and the var {$person["name"]}!', '"') . '"'
	*
	* 		When addCharSlashesWithPHPVarsControl is called, then the it will return:
	*			'"this is a simple phrase with double quotes \" and the var {$person["name"]}!"'
	* 		When addCharSlashes is called, then the it will return:
	*			'"this is a simple phrase with double quotes \" and the var {$person[\"name\"]}!"'
	*			...which will return a php error, bc what is inside of {$...} will be executed first in php!
	*
	* 	$add_slash_to_escaped_char: 
	* 		if true, detects if the $char is escaped (this is if there is a slash before) and if it is, escapes the char and the previous slash that was escaping the $char
	* 		if false, simply escapes the $char
	*/";}s:25:"start_comments_line_index";i:470;s:26:"start_comments_token_index";i:3343;s:23:"end_comments_line_index";i:496;s:24:"end_comments_token_index";i:3347;s:22:"start_args_token_index";i:3356;s:20:"end_args_token_index";i:3375;s:9:"arguments";a:4:{s:5:"$text";N;s:5:"$char";N;s:26:"$add_slash_to_escaped_char";s:4:"true";s:11:"$text_chars";s:4:"null";}s:25:"start_brackets_line_index";i:513;s:26:"start_brackets_token_index";i:3377;s:23:"end_brackets_line_index";i:541;s:24:"end_brackets_token_index";i:3635;s:14:"end_line_index";i:541;s:15:"end_token_index";i:3635;}s:10:"mbStrSplit";a:21:{s:4:"name";s:10:"mbStrSplit";s:16:"start_line_index";i:580;s:17:"start_token_index";i:3643;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:121:"//This method is deprecated bc mb_substr is too slow. mb_substr should only be used if we don't change the $text it-self.";i:1;s:1452:"/*public static function addCharSlashesWithPHPVarsControlOld($text, $char, $add_slash_to_escaped_char = true) {
		//error_log("addCharSlashesWithPHPVarsControl(\$text, $char, $add_slash_to_escaped_char\n\n", 3, "/var/www/html/livingroop/default/tmp/test.log");
		
		$l = mb_strlen($text);
		$is_var = 0;
		//error_log("length:$l|".strlen($text)."\n\n", 3, "/var/www/html/livingroop/default/tmp/test.log");
		
		for ($i = 0; $i < $l; $i++) {
			$c = mb_substr($text, $i, 1);
			
			if ($c == '$' && (mb_substr($text, $i - 1, 1) == "{" || mb_substr($text, $i + 1, 1) == "{") && !self::isMBSubstrCharEscaped($text, $i)) //{$...} or ${...}
				$is_var++;
			else if ($is_var && $c == "}")
				$is_var--;
			else if (!$is_var && $c == $char) {
				if ($add_slash_to_escaped_char && self::isMBSubstrCharEscaped($text, $i)) {
					$text = mb_substr($text, 0, $i) . "\\\\" . mb_substr($text, $i); //adds 2 slashes: one for the existent slash that escapes the $char, and another adds a 2nd slash to the $char
					$i += 2; //move $pos to the new $char position
					$l += 2; //increase 2 char to length
				}
				else {
					$text = mb_substr($text, 0, $i) . "\\" . mb_substr($text, $i); //only adds 1 slash to the $char
					$i += 1; //move $pos to the new $char position
					$l += 1; //increase 1 char to length
				}
			}
		}
		//error_log("END\n\n", 3, "/var/www/html/livingroop/default/tmp/test.log");
		
		return $text;
	}*/";}s:12:"doc_comments";a:1:{i:0;s:251:"/**
	* mbStrSplit: returns the multibyte character list of a string. 
	* This function splits a multibyte string into an array of characters. Comparable to str_split().
	* A (simpler) way to extract all characters from a UTF-8 string to array.
	*/";}s:25:"start_comments_line_index";i:542;s:26:"start_comments_token_index";i:3637;s:23:"end_comments_line_index";i:575;s:24:"end_comments_token_index";i:3641;s:22:"start_args_token_index";i:3650;s:20:"end_args_token_index";i:3652;s:9:"arguments";a:1:{s:4:"$str";N;}s:25:"start_brackets_line_index";i:580;s:26:"start_brackets_token_index";i:3654;s:23:"end_brackets_line_index";i:584;s:24:"end_brackets_token_index";i:3691;s:14:"end_line_index";i:584;s:15:"end_token_index";i:3691;}s:13:"isCharEscaped";a:20:{s:4:"name";s:13:"isCharEscaped";s:16:"start_line_index";i:589;s:17:"start_token_index";i:3695;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:75:"/**
	* isCharEscaped: checks if a char is escaped given its position 
	*/";}s:25:"start_comments_line_index";i:586;s:26:"start_comments_token_index";i:3693;s:23:"end_comments_line_index";i:586;s:24:"end_comments_token_index";i:3693;s:22:"start_args_token_index";i:3702;s:20:"end_args_token_index";i:3707;s:9:"arguments";a:2:{s:4:"$str";N;s:6:"$index";N;}s:25:"start_brackets_line_index";i:589;s:26:"start_brackets_token_index";i:3709;s:23:"end_brackets_line_index";i:603;s:24:"end_brackets_token_index";i:3797;s:14:"end_line_index";i:603;s:15:"end_token_index";i:3797;}s:15:"isMBCharEscaped";a:20:{s:4:"name";s:15:"isMBCharEscaped";s:16:"start_line_index";i:608;s:17:"start_token_index";i:3801;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:75:"/**
	* isCharEscaped: checks if a char is escaped given its position 
	*/";}s:25:"start_comments_line_index";i:605;s:26:"start_comments_token_index";i:3799;s:23:"end_comments_line_index";i:605;s:24:"end_comments_token_index";i:3799;s:22:"start_args_token_index";i:3808;s:20:"end_args_token_index";i:3820;s:9:"arguments";a:3:{s:4:"$str";N;s:6:"$index";N;s:11:"$text_chars";s:4:"null";}s:25:"start_brackets_line_index";i:608;s:26:"start_brackets_token_index";i:3822;s:23:"end_brackets_line_index";i:620;s:24:"end_brackets_token_index";i:3911;s:14:"end_line_index";i:620;s:15:"end_token_index";i:3911;}s:21:"isMBSubstrCharEscaped";a:20:{s:4:"name";s:21:"isMBSubstrCharEscaped";s:16:"start_line_index";i:625;s:17:"start_token_index";i:3915;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:118:"/**
	* isMBSubstrCharEscaped: checks if a char is escaped given its position based in the mb_substr php function
	*/";}s:25:"start_comments_line_index";i:622;s:26:"start_comments_token_index";i:3913;s:23:"end_comments_line_index";i:622;s:24:"end_comments_token_index";i:3913;s:22:"start_args_token_index";i:3922;s:20:"end_args_token_index";i:3927;s:9:"arguments";a:2:{s:4:"$str";N;s:6:"$index";N;}s:25:"start_brackets_line_index";i:625;s:26:"start_brackets_token_index";i:3929;s:23:"end_brackets_line_index";i:636;s:24:"end_brackets_token_index";i:4004;s:14:"end_line_index";i:636;s:15:"end_token_index";i:4004;}s:9:"isBadWord";a:20:{s:4:"name";s:9:"isBadWord";s:16:"start_line_index";i:641;s:17:"start_token_index";i:4008;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:59:"/**
	* isBadWord: verifies if a string is a bad word.
	*/";}s:25:"start_comments_line_index";i:638;s:26:"start_comments_token_index";i:4006;s:23:"end_comments_line_index";i:638;s:24:"end_comments_token_index";i:4006;s:22:"start_args_token_index";i:4015;s:20:"end_args_token_index";i:4017;s:9:"arguments";a:1:{s:7:"$string";N;}s:25:"start_brackets_line_index";i:641;s:26:"start_brackets_token_index";i:4019;s:23:"end_brackets_line_index";i:649;s:24:"end_brackets_token_index";i:4066;s:14:"end_line_index";i:649;s:15:"end_token_index";i:4066;}s:15:"replaceBadWords";a:20:{s:4:"name";s:15:"replaceBadWords";s:16:"start_line_index";i:654;s:17:"start_token_index";i:4070;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:64:"/**
	* replaceBadWords: replaces bad words with nicer ones
	*/";}s:25:"start_comments_line_index";i:651;s:26:"start_comments_token_index";i:4068;s:23:"end_comments_line_index";i:651;s:24:"end_comments_token_index";i:4068;s:22:"start_args_token_index";i:4077;s:20:"end_args_token_index";i:4079;s:9:"arguments";a:1:{s:7:"$string";N;}s:25:"start_brackets_line_index";i:654;s:26:"start_brackets_token_index";i:4081;s:23:"end_brackets_line_index";i:661;s:24:"end_brackets_token_index";i:4128;s:14:"end_line_index";i:661;s:15:"end_token_index";i:4128;}s:15:"replaceWebLinks";a:20:{s:4:"name";s:15:"replaceWebLinks";s:16:"start_line_index";i:666;s:17:"start_token_index";i:4132;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:48:"/**
	* replaceWebLinks: replaces web links
	*/";}s:25:"start_comments_line_index";i:663;s:26:"start_comments_token_index";i:4130;s:23:"end_comments_line_index";i:663;s:24:"end_comments_token_index";i:4130;s:22:"start_args_token_index";i:4139;s:20:"end_args_token_index";i:4148;s:9:"arguments";a:2:{s:7:"$string";N;s:12:"$replacement";s:2:"""";}s:25:"start_brackets_line_index";i:666;s:26:"start_brackets_token_index";i:4150;s:23:"end_brackets_line_index";i:699;s:24:"end_brackets_token_index";i:4386;s:14:"end_line_index";i:699;s:15:"end_token_index";i:4386;}s:14:"breakLongWords";a:20:{s:4:"name";s:14:"breakLongWords";s:16:"start_line_index";i:704;s:17:"start_token_index";i:4390;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:46:"/**
	* breakLongWords: breaks long words
	*/";}s:25:"start_comments_line_index";i:701;s:26:"start_comments_token_index";i:4388;s:23:"end_comments_line_index";i:701;s:24:"end_comments_token_index";i:4388;s:22:"start_args_token_index";i:4397;s:20:"end_args_token_index";i:4413;s:9:"arguments";a:3:{s:7:"$string";N;s:10:"$maxLength";s:2:"20";s:5:"$html";s:5:"false";}s:25:"start_brackets_line_index";i:704;s:26:"start_brackets_token_index";i:4415;s:23:"end_brackets_line_index";i:708;s:24:"end_brackets_token_index";i:4463;s:14:"end_line_index";i:708;s:15:"end_token_index";i:4463;}s:18:"breakLongTextWords";a:20:{s:4:"name";s:18:"breakLongTextWords";s:16:"start_line_index";i:713;s:17:"start_token_index";i:4467;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:55:"/**
	* breakLongTextWords: breaks long text words
	*/";}s:25:"start_comments_line_index";i:710;s:26:"start_comments_token_index";i:4465;s:23:"end_comments_line_index";i:710;s:24:"end_comments_token_index";i:4465;s:22:"start_args_token_index";i:4474;s:20:"end_args_token_index";i:4483;s:9:"arguments";a:2:{s:7:"$string";N;s:10:"$maxLength";s:2:"20";}s:25:"start_brackets_line_index";i:713;s:26:"start_brackets_token_index";i:4485;s:23:"end_brackets_line_index";i:731;s:24:"end_brackets_token_index";i:4629;s:14:"end_line_index";i:731;s:15:"end_token_index";i:4629;}s:18:"breakLongHtmlWords";a:20:{s:4:"name";s:18:"breakLongHtmlWords";s:16:"start_line_index";i:736;s:17:"start_token_index";i:4633;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:55:"/**
	* breakLongHtmlWords: breaks long html words
	*/";}s:25:"start_comments_line_index";i:733;s:26:"start_comments_token_index";i:4631;s:23:"end_comments_line_index";i:733;s:24:"end_comments_token_index";i:4631;s:22:"start_args_token_index";i:4640;s:20:"end_args_token_index";i:4656;s:9:"arguments";a:3:{s:4:"$str";N;s:10:"$maxLength";s:2:"20";s:5:"$char";s:3:"" "";}s:25:"start_brackets_line_index";i:736;s:26:"start_brackets_token_index";i:4657;s:23:"end_brackets_line_index";i:772;s:24:"end_brackets_token_index";i:4900;s:14:"end_line_index";i:772;s:15:"end_token_index";i:4900;}s:14:"sanitizeString";a:20:{s:4:"name";s:14:"sanitizeString";s:16:"start_line_index";i:777;s:17:"start_token_index";i:4904;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:29:"/**
	* sanitizeString: 
	*/";}s:25:"start_comments_line_index";i:774;s:26:"start_comments_token_index";i:4902;s:23:"end_comments_line_index";i:774;s:24:"end_comments_token_index";i:4902;s:22:"start_args_token_index";i:4911;s:20:"end_args_token_index";i:4920;s:9:"arguments";a:2:{s:7:"$string";N;s:5:"$html";s:5:"false";}s:25:"start_brackets_line_index";i:777;s:26:"start_brackets_token_index";i:4922;s:23:"end_brackets_line_index";i:785;s:24:"end_brackets_token_index";i:4981;s:14:"end_line_index";i:785;s:15:"end_token_index";i:4981;}s:12:"sanitizeText";a:20:{s:4:"name";s:12:"sanitizeText";s:16:"start_line_index";i:790;s:17:"start_token_index";i:4985;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:27:"/**
	* sanitizeText: 
	*/";}s:25:"start_comments_line_index";i:787;s:26:"start_comments_token_index";i:4983;s:23:"end_comments_line_index";i:787;s:24:"end_comments_token_index";i:4983;s:22:"start_args_token_index";i:4992;s:20:"end_args_token_index";i:5001;s:9:"arguments";a:2:{s:7:"$string";N;s:5:"$html";s:5:"false";}s:25:"start_brackets_line_index";i:790;s:26:"start_brackets_token_index";i:5003;s:23:"end_brackets_line_index";i:809;s:24:"end_brackets_token_index";i:5176;s:14:"end_line_index";i:809;s:15:"end_token_index";i:5176;}}}}
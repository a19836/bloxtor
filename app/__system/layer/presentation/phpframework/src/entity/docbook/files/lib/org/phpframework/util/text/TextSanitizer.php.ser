a:1:{s:13:"TextSanitizer";a:1:{s:7:"methods";a:22:{s:31:"convertBinaryCodeInTextToBase64";a:20:{s:4:"name";s:31:"convertBinaryCodeInTextToBase64";s:16:"start_line_index";i:12;s:17:"start_token_index";i:11;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:115:"//in case you have normal text mixed with binary code, then this function converts only the binary chras to base64.";}s:25:"start_comments_line_index";i:11;s:26:"start_comments_token_index";i:9;s:23:"end_comments_line_index";i:11;s:24:"end_comments_token_index";i:9;s:22:"start_args_token_index";i:18;s:20:"end_args_token_index";i:20;s:9:"arguments";a:1:{s:5:"$text";N;}s:25:"start_brackets_line_index";i:12;s:26:"start_brackets_token_index";i:22;s:23:"end_brackets_line_index";i:54;s:24:"end_brackets_token_index";i:409;s:14:"end_line_index";i:54;s:15:"end_token_index";i:409;}s:16:"normalizeAccents";a:20:{s:4:"name";s:16:"normalizeAccents";s:16:"start_line_index";i:58;s:17:"start_token_index";i:415;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:71:"//copied from https://www.php.net/manual/pt_BR/normalizer.normalize.php";i:1;s:81:"//remove accents and replace them by the correspondent character without accents.";}s:25:"start_comments_line_index";i:56;s:26:"start_comments_token_index";i:411;s:23:"end_comments_line_index";i:57;s:24:"end_comments_token_index";i:413;s:22:"start_args_token_index";i:422;s:20:"end_args_token_index";i:424;s:9:"arguments";a:1:{s:2:"$s";N;}s:25:"start_brackets_line_index";i:58;s:26:"start_brackets_token_index";i:426;s:23:"end_brackets_line_index";i:125;s:24:"end_brackets_token_index";i:1328;s:14:"end_line_index";i:125;s:15:"end_token_index";i:1328;}s:55:"replaceEscapedEndLinesInsideOfPHPDoubleQuotesInHtmlCode";a:20:{s:4:"name";s:55:"replaceEscapedEndLinesInsideOfPHPDoubleQuotesInHtmlCode";s:16:"start_line_index";i:130;s:17:"start_token_index";i:1336;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:3:{i:0;s:85:"//replace \n inside of double quotes variables, bc prettyPrint escapes the end lines.";i:1;s:54:"//Note that $text is a html code with php code inside.";i:2;s:173:"//This method should be used in the code generated by the PhpParser\PrettyPrinter\Standard->prettyPrint($stmts); See an example in CMSFileHandler::setMethodParamsFromContent";}s:25:"start_comments_line_index";i:127;s:26:"start_comments_token_index";i:1330;s:23:"end_comments_line_index";i:129;s:24:"end_comments_token_index";i:1334;s:22:"start_args_token_index";i:1343;s:20:"end_args_token_index";i:1345;s:9:"arguments";a:1:{s:5:"$text";N;}s:25:"start_brackets_line_index";i:130;s:26:"start_brackets_token_index";i:1347;s:23:"end_brackets_line_index";i:175;s:24:"end_brackets_token_index";i:1794;s:14:"end_line_index";i:175;s:15:"end_token_index";i:1794;}s:19:"replaceIfNotEscaped";a:21:{s:4:"name";s:19:"replaceIfNotEscaped";s:16:"start_line_index";i:181;s:17:"start_token_index";i:1800;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:154:"//Used in this class and in lib/org/phpframework/workflow/task/programming/createform/WorkFlowTaskImpl.php and lib/org/phpframework/.../CMSFileHandler.php";}s:12:"doc_comments";a:1:{i:0;s:224:"/**
	* replaceIfNotEscaped: replaces a string inside of another string if not escaped, this is, repace $to_replace by $to_replacement in $text if $to_replace not escaped. Return the new string with the values replaced.
	*/";}s:25:"start_comments_line_index";i:177;s:26:"start_comments_token_index";i:1796;s:23:"end_comments_line_index";i:180;s:24:"end_comments_token_index";i:1798;s:22:"start_args_token_index";i:1807;s:20:"end_args_token_index";i:1815;s:9:"arguments";a:3:{s:11:"$to_replace";N;s:12:"$replacement";N;s:5:"$text";N;}s:25:"start_brackets_line_index";i:181;s:26:"start_brackets_token_index";i:1817;s:23:"end_brackets_line_index";i:210;s:24:"end_brackets_token_index";i:2047;s:14:"end_line_index";i:210;s:15:"end_token_index";i:2047;}s:13:"stripCSlashes";a:21:{s:4:"name";s:13:"stripCSlashes";s:16:"start_line_index";i:247;s:17:"start_token_index";i:2055;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:56:"//This method is deprecated bc is a little bit more slow";i:1;s:726:"/*public static function replaceIfNotEscapedOld($to_replace, $replacement, $text) {
		if ($text) {
			$new_text = "";
			$pos = 0;
			
			do {
				$start_pos = mb_strpos($text, $to_replace, $pos);
				
				if ($start_pos !== false) {
					$escaped = self::isMBSubstrCharEscaped($text, $start_pos);
					$next_pos = $start_pos + strlen($to_replace);
					
					if (!$escaped)
						$new_text .= mb_substr($text, $pos, $start_pos - $pos) . $replacement;
					else
						$new_text .= mb_substr($text, $pos, $next_pos - $pos);
					
					$pos = $next_pos;
				}
				else
					$new_text .= mb_substr($text, $pos);
			}
			while($start_pos !== false);
			
			return $new_text;
		}
		
		return $text;
	}*/";}s:12:"doc_comments";a:1:{i:0;s:432:"/**
	* stripCSlashes: strip all slashes for all characters inside of $chars
	* Note that the stripcslashes and stripslashes have a diferent behaviour. The stripcslashes removes slashes for double quotes and the stripslashes remove slashes for a bunch of escaped chars. 
	* This method only removes the slashes for a specific chars and if the chars are escaped, this is, if there is "\\'", this method won't remove any slash.
	*/";}s:25:"start_comments_line_index";i:211;s:26:"start_comments_token_index";i:2049;s:23:"end_comments_line_index";i:242;s:24:"end_comments_token_index";i:2053;s:22:"start_args_token_index";i:2062;s:20:"end_args_token_index";i:2067;s:9:"arguments";a:2:{s:5:"$text";N;s:6:"$chars";N;}s:25:"start_brackets_line_index";i:247;s:26:"start_brackets_token_index";i:2069;s:23:"end_brackets_line_index";i:262;s:24:"end_brackets_token_index";i:2196;s:14:"end_line_index";i:262;s:15:"end_token_index";i:2196;}s:16:"stripCharSlashes";a:20:{s:4:"name";s:16:"stripCharSlashes";s:16:"start_line_index";i:267;s:17:"start_token_index";i:2200;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:73:"/**
	* stripCharSlashes: strip all slashes for a specific character
	*/";}s:25:"start_comments_line_index";i:264;s:26:"start_comments_token_index";i:2198;s:23:"end_comments_line_index";i:264;s:24:"end_comments_token_index";i:2198;s:22:"start_args_token_index";i:2207;s:20:"end_args_token_index";i:2212;s:9:"arguments";a:2:{s:5:"$text";N;s:5:"$char";N;}s:25:"start_brackets_line_index";i:267;s:26:"start_brackets_token_index";i:2214;s:23:"end_brackets_line_index";i:282;s:24:"end_brackets_token_index";i:2354;s:14:"end_line_index";i:282;s:15:"end_token_index";i:2354;}s:23:"addCSlashesExcludingPTL";a:21:{s:4:"name";s:23:"addCSlashesExcludingPTL";s:16:"start_line_index";i:312;s:17:"start_token_index";i:2362;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:56:"//This method is deprecated bc is a little bit more slow";i:1;s:440:"/*public static function stripCharSlashesOld($text, $char) {
		$pos = 0;
		
		do {
			$pos = mb_strpos($text, $char, $pos);
			
			if ($pos !== false) {
				$prev = mb_substr($text, $pos - 1, 1);
				
				if ($prev == "\\" && !self::isMBSubstrCharEscaped($text, $pos - 1))
					$text = mb_substr($text, 0, $pos - 1) . mb_substr($text, $pos);
				else
					$pos++;
			}
		}
		while ($pos !== false);
		
		return $text;
	}*/";}s:12:"doc_comments";a:1:{i:0;s:440:"/**
	* addCSlashesExcludingPTL: add slashes to all characters inside of $chars but excluding the ptl instructions
	*	$text: is the html with ptl instructions
	* 	$chars are the chars to be escaped: like: '\\"'
	* 	$php_vars_control: check the addCharSlashesWithPHPVarsControl method
	*
	* In the future change this method to use the mbStrSplit method instead of the mb_substr, bc the mb_substr method is too slow for long strings
	*/";}s:25:"start_comments_line_index";i:283;s:26:"start_comments_token_index";i:2356;s:23:"end_comments_line_index";i:304;s:24:"end_comments_token_index";i:2360;s:22:"start_args_token_index";i:2369;s:20:"end_args_token_index";i:2381;s:9:"arguments";a:3:{s:5:"$text";N;s:6:"$chars";N;s:17:"$php_vars_control";s:4:"true";}s:25:"start_brackets_line_index";i:312;s:26:"start_brackets_token_index";i:2383;s:23:"end_brackets_line_index";i:363;s:24:"end_brackets_token_index";i:2944;s:14:"end_line_index";i:363;s:15:"end_token_index";i:2944;}s:11:"addCSlashes";a:21:{s:4:"name";s:11:"addCSlashes";s:16:"start_line_index";i:426;s:17:"start_token_index";i:2952;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:56:"//This method is deprecated bc is a little bit more slow";i:1;s:1819:"/*public static function addCSlashesExcludingPTLOld($text, $chars, $php_vars_control = true) {
		$length = mb_strlen($text);
		$new_text = "";
		$start_pos = $end_pos = 0;
		
		do {
			$pos_1 = mb_strpos($text, "<ptl:", $start_pos);
			$pos_2 = mb_strpos($text, "<php:", $start_pos);
			$pos_3 = mb_strpos($text, "<?:", $start_pos);
			$pos_4 = mb_strpos($text, "<?php:", $start_pos);
			
			$end_pos = $pos_1;
			
			if (!$end_pos || ($pos_2 && $end_pos > $pos_2))
				$end_pos = $pos_2;
			
			if (!$end_pos || ($pos_3 && $end_pos > $pos_3))
				$end_pos = $pos_3;
			
			if (!$end_pos || ($pos_4 && $end_pos > $pos_4))
				$end_pos = $pos_4;
			
			if ($end_pos !== false) {
				$str = mb_substr($text, $start_pos, $end_pos - $start_pos);
				$new_text .= self::addCSlashes($str, $chars, $php_vars_control); //add previous code of ptl tag
				$start_pos = $length;
				
				//find start pos
				$double_quotes_open = $single_quotes_open = false;
				for ($i = $end_pos + 1; $i < $length; $i++) {
					$c = mb_substr($text, $i, 1);
					
					if ($c == '"' && !$single_quotes_open && !self::isMBSubstrCharEscaped($text, $i))
						$double_quotes_open = !$double_quotes_open;
					else if ($c == "'" && !$double_quotes_open && !self::isMBSubstrCharEscaped($text, $i))
						$single_quotes_open = !$single_quotes_open;
					else if ($c == ">" && !$double_quotes_open && !$single_quotes_open) {
						$start_pos = $i + 1;
						break;
					}
				}
				
				$new_text .= mb_substr($text, $end_pos, $start_pos - $end_pos); //add ptl tag
			}
			else {
				$str = mb_substr($text, $start_pos);
				$new_text .= self::addCSlashes($str, $chars, $php_vars_control); //add last code or all code if no tpl tags
			}
		}
		while($end_pos !== false);
		
		return $new_text;
	}*/";}s:12:"doc_comments";a:1:{i:0;s:676:"/**
	* addCSlashes: add slashes to all characters inside of $chars
	* Note that the addcslashes and addslashes have a diferent behaviour. The addcslashes adds slashes for all double quotes even if they are escaped and the addslashes remove slashes for a bunch of escaped chars. 
	* This method only adds slashes for a specific chars and if the chars are escaped, this is, if there is "\'", this method will add a slash to "\" and another to "'", converting the code to "\\\'". But if there a code like "\\'", this method will convert it to: "\\\'". This means that this code is intelligent.
	*
	* 	$php_vars_control: check the addCharSlashesWithPHPVarsControl method
	*/";}s:25:"start_comments_line_index";i:364;s:26:"start_comments_token_index";i:2946;s:23:"end_comments_line_index";i:419;s:24:"end_comments_token_index";i:2950;s:22:"start_args_token_index";i:2959;s:20:"end_args_token_index";i:2971;s:9:"arguments";a:3:{s:5:"$text";N;s:6:"$chars";N;s:17:"$php_vars_control";s:5:"false";}s:25:"start_brackets_line_index";i:426;s:26:"start_brackets_token_index";i:2973;s:23:"end_brackets_line_index";i:446;s:24:"end_brackets_token_index";i:3132;s:14:"end_line_index";i:446;s:15:"end_token_index";i:3132;}s:14:"addCharSlashes";a:20:{s:4:"name";s:14:"addCharSlashes";s:16:"start_line_index";i:457;s:17:"start_token_index";i:3136;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:388:"/**
	* addCharSlashes: add slashes for a specific character
	*
	* 	$add_slash_to_escaped_char: 
	* 		if true, detects if the $char is escaped (this is if there is a slash before) and if it is, escapes the char and the previous slash that was escaping the $char
	* 		if false, simply escapes the $char
	*
	* 	$php_vars_control: check the addCharSlashesWithPHPVarsControl method
	*/";}s:25:"start_comments_line_index";i:448;s:26:"start_comments_token_index";i:3134;s:23:"end_comments_line_index";i:448;s:24:"end_comments_token_index";i:3134;s:22:"start_args_token_index";i:3143;s:20:"end_args_token_index";i:3162;s:9:"arguments";a:4:{s:5:"$text";N;s:5:"$char";N;s:26:"$add_slash_to_escaped_char";s:4:"true";s:17:"$php_vars_control";s:5:"false";}s:25:"start_brackets_line_index";i:457;s:26:"start_brackets_token_index";i:3164;s:23:"end_brackets_line_index";i:476;s:24:"end_brackets_token_index";i:3343;s:14:"end_line_index";i:476;s:15:"end_token_index";i:3343;}s:32:"addCharSlashesWithPHPVarsControl";a:21:{s:4:"name";s:32:"addCharSlashesWithPHPVarsControl";s:16:"start_line_index";i:520;s:17:"start_token_index";i:3351;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:121:"//This method is deprecated bc mb_substr is too slow. mb_substr should only be used if we don't change the $text it-self.";i:1;s:1005:"/*public static function addCharSlashesOld($text, $char, $add_slash_to_escaped_char = true, $php_vars_control = false) {
		if ($php_vars_control && (mb_strpos($text, '{$') !== false || mb_strpos($text, '${') !== false))
			return self::addCharSlashesWithPHPVarsControl($text, $char, $add_slash_to_escaped_char);
		
		$pos = 0;
		
		do {
			$pos = mb_strpos($text, $char, $pos);
			
			if ($pos !== false) {
				if ($add_slash_to_escaped_char && self::isMBSubstrCharEscaped($text, $pos)) {
					$text = mb_substr($text, 0, $pos) . "\\\\" . mb_substr($text, $pos); //adds 2 slashes: one for the existent slash that escapes the $char, and another adds a 2nd slash to the $char
					$pos += 3; //move $pos to the next position after $char
				}
				else {
					$text = mb_substr($text, 0, $pos) . "\\" . mb_substr($text, $pos); //only adds 1 slash to the $char
					$pos += 2; //move $pos to the next position after $char
				}
			}
		}
		while ($pos !== false);
		
		return $text;
	}*/";}s:12:"doc_comments";a:1:{i:0;s:1115:"/**
	* addCharSlashesWithPHPVarsControl: add slashes for a specific character but only in the text outside of the php vars like ${...} or {$...}
	*
	* 	This is, checks if exists any '{$' or '${' and if yes, doesn't escapes anything inside of the brackets, bc it is a php var that should not be touched.
	* 		example: 
	*			'"' . self::addCharSlashes('this is a simple phrase with double quotes " and the var {$person["name"]}!', '"') . '"'
	*
	* 		When addCharSlashesWithPHPVarsControl is called, then the it will return:
	*			'"this is a simple phrase with double quotes \" and the var {$person["name"]}!"'
	* 		When addCharSlashes is called, then the it will return:
	*			'"this is a simple phrase with double quotes \" and the var {$person[\"name\"]}!"'
	*			...which will return a php error, bc what is inside of {$...} will be executed first in php!
	*
	* 	$add_slash_to_escaped_char: 
	* 		if true, detects if the $char is escaped (this is if there is a slash before) and if it is, escapes the char and the previous slash that was escaping the $char
	* 		if false, simply escapes the $char
	*/";}s:25:"start_comments_line_index";i:477;s:26:"start_comments_token_index";i:3345;s:23:"end_comments_line_index";i:503;s:24:"end_comments_token_index";i:3349;s:22:"start_args_token_index";i:3358;s:20:"end_args_token_index";i:3377;s:9:"arguments";a:4:{s:5:"$text";N;s:5:"$char";N;s:26:"$add_slash_to_escaped_char";s:4:"true";s:11:"$text_chars";s:4:"null";}s:25:"start_brackets_line_index";i:520;s:26:"start_brackets_token_index";i:3379;s:23:"end_brackets_line_index";i:548;s:24:"end_brackets_token_index";i:3637;s:14:"end_line_index";i:548;s:15:"end_token_index";i:3637;}s:10:"mbStrSplit";a:21:{s:4:"name";s:10:"mbStrSplit";s:16:"start_line_index";i:587;s:17:"start_token_index";i:3645;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:121:"//This method is deprecated bc mb_substr is too slow. mb_substr should only be used if we don't change the $text it-self.";i:1;s:1452:"/*public static function addCharSlashesWithPHPVarsControlOld($text, $char, $add_slash_to_escaped_char = true) {
		//error_log("addCharSlashesWithPHPVarsControl(\$text, $char, $add_slash_to_escaped_char\n\n", 3, "/var/www/html/livingroop/default/tmp/test.log");
		
		$l = mb_strlen($text);
		$is_var = 0;
		//error_log("length:$l|".strlen($text)."\n\n", 3, "/var/www/html/livingroop/default/tmp/test.log");
		
		for ($i = 0; $i < $l; $i++) {
			$c = mb_substr($text, $i, 1);
			
			if ($c == '$' && (mb_substr($text, $i - 1, 1) == "{" || mb_substr($text, $i + 1, 1) == "{") && !self::isMBSubstrCharEscaped($text, $i)) //{$...} or ${...}
				$is_var++;
			else if ($is_var && $c == "}")
				$is_var--;
			else if (!$is_var && $c == $char) {
				if ($add_slash_to_escaped_char && self::isMBSubstrCharEscaped($text, $i)) {
					$text = mb_substr($text, 0, $i) . "\\\\" . mb_substr($text, $i); //adds 2 slashes: one for the existent slash that escapes the $char, and another adds a 2nd slash to the $char
					$i += 2; //move $pos to the new $char position
					$l += 2; //increase 2 char to length
				}
				else {
					$text = mb_substr($text, 0, $i) . "\\" . mb_substr($text, $i); //only adds 1 slash to the $char
					$i += 1; //move $pos to the new $char position
					$l += 1; //increase 1 char to length
				}
			}
		}
		//error_log("END\n\n", 3, "/var/www/html/livingroop/default/tmp/test.log");
		
		return $text;
	}*/";}s:12:"doc_comments";a:1:{i:0;s:251:"/**
	* mbStrSplit: returns the multibyte character list of a string. 
	* This function splits a multibyte string into an array of characters. Comparable to str_split().
	* A (simpler) way to extract all characters from a UTF-8 string to array.
	*/";}s:25:"start_comments_line_index";i:549;s:26:"start_comments_token_index";i:3639;s:23:"end_comments_line_index";i:582;s:24:"end_comments_token_index";i:3643;s:22:"start_args_token_index";i:3652;s:20:"end_args_token_index";i:3654;s:9:"arguments";a:1:{s:4:"$str";N;}s:25:"start_brackets_line_index";i:587;s:26:"start_brackets_token_index";i:3656;s:23:"end_brackets_line_index";i:591;s:24:"end_brackets_token_index";i:3693;s:14:"end_line_index";i:591;s:15:"end_token_index";i:3693;}s:13:"isCharEscaped";a:20:{s:4:"name";s:13:"isCharEscaped";s:16:"start_line_index";i:596;s:17:"start_token_index";i:3697;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:75:"/**
	* isCharEscaped: checks if a char is escaped given its position 
	*/";}s:25:"start_comments_line_index";i:593;s:26:"start_comments_token_index";i:3695;s:23:"end_comments_line_index";i:593;s:24:"end_comments_token_index";i:3695;s:22:"start_args_token_index";i:3704;s:20:"end_args_token_index";i:3709;s:9:"arguments";a:2:{s:4:"$str";N;s:6:"$index";N;}s:25:"start_brackets_line_index";i:596;s:26:"start_brackets_token_index";i:3711;s:23:"end_brackets_line_index";i:610;s:24:"end_brackets_token_index";i:3799;s:14:"end_line_index";i:610;s:15:"end_token_index";i:3799;}s:15:"isMBCharEscaped";a:20:{s:4:"name";s:15:"isMBCharEscaped";s:16:"start_line_index";i:615;s:17:"start_token_index";i:3803;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:75:"/**
	* isCharEscaped: checks if a char is escaped given its position 
	*/";}s:25:"start_comments_line_index";i:612;s:26:"start_comments_token_index";i:3801;s:23:"end_comments_line_index";i:612;s:24:"end_comments_token_index";i:3801;s:22:"start_args_token_index";i:3810;s:20:"end_args_token_index";i:3822;s:9:"arguments";a:3:{s:4:"$str";N;s:6:"$index";N;s:11:"$text_chars";s:4:"null";}s:25:"start_brackets_line_index";i:615;s:26:"start_brackets_token_index";i:3824;s:23:"end_brackets_line_index";i:627;s:24:"end_brackets_token_index";i:3913;s:14:"end_line_index";i:627;s:15:"end_token_index";i:3913;}s:21:"isMBSubstrCharEscaped";a:20:{s:4:"name";s:21:"isMBSubstrCharEscaped";s:16:"start_line_index";i:632;s:17:"start_token_index";i:3917;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:118:"/**
	* isMBSubstrCharEscaped: checks if a char is escaped given its position based in the mb_substr php function
	*/";}s:25:"start_comments_line_index";i:629;s:26:"start_comments_token_index";i:3915;s:23:"end_comments_line_index";i:629;s:24:"end_comments_token_index";i:3915;s:22:"start_args_token_index";i:3924;s:20:"end_args_token_index";i:3929;s:9:"arguments";a:2:{s:4:"$str";N;s:6:"$index";N;}s:25:"start_brackets_line_index";i:632;s:26:"start_brackets_token_index";i:3931;s:23:"end_brackets_line_index";i:643;s:24:"end_brackets_token_index";i:4006;s:14:"end_line_index";i:643;s:15:"end_token_index";i:4006;}s:9:"isBadWord";a:20:{s:4:"name";s:9:"isBadWord";s:16:"start_line_index";i:648;s:17:"start_token_index";i:4010;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:59:"/**
	* isBadWord: verifies if a string is a bad word.
	*/";}s:25:"start_comments_line_index";i:645;s:26:"start_comments_token_index";i:4008;s:23:"end_comments_line_index";i:645;s:24:"end_comments_token_index";i:4008;s:22:"start_args_token_index";i:4017;s:20:"end_args_token_index";i:4019;s:9:"arguments";a:1:{s:7:"$string";N;}s:25:"start_brackets_line_index";i:648;s:26:"start_brackets_token_index";i:4021;s:23:"end_brackets_line_index";i:656;s:24:"end_brackets_token_index";i:4068;s:14:"end_line_index";i:656;s:15:"end_token_index";i:4068;}s:15:"replaceBadWords";a:20:{s:4:"name";s:15:"replaceBadWords";s:16:"start_line_index";i:661;s:17:"start_token_index";i:4072;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:64:"/**
	* replaceBadWords: replaces bad words with nicer ones
	*/";}s:25:"start_comments_line_index";i:658;s:26:"start_comments_token_index";i:4070;s:23:"end_comments_line_index";i:658;s:24:"end_comments_token_index";i:4070;s:22:"start_args_token_index";i:4079;s:20:"end_args_token_index";i:4081;s:9:"arguments";a:1:{s:7:"$string";N;}s:25:"start_brackets_line_index";i:661;s:26:"start_brackets_token_index";i:4083;s:23:"end_brackets_line_index";i:668;s:24:"end_brackets_token_index";i:4130;s:14:"end_line_index";i:668;s:15:"end_token_index";i:4130;}s:15:"replaceWebLinks";a:20:{s:4:"name";s:15:"replaceWebLinks";s:16:"start_line_index";i:673;s:17:"start_token_index";i:4134;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:48:"/**
	* replaceWebLinks: replaces web links
	*/";}s:25:"start_comments_line_index";i:670;s:26:"start_comments_token_index";i:4132;s:23:"end_comments_line_index";i:670;s:24:"end_comments_token_index";i:4132;s:22:"start_args_token_index";i:4141;s:20:"end_args_token_index";i:4150;s:9:"arguments";a:2:{s:7:"$string";N;s:12:"$replacement";s:2:"""";}s:25:"start_brackets_line_index";i:673;s:26:"start_brackets_token_index";i:4152;s:23:"end_brackets_line_index";i:706;s:24:"end_brackets_token_index";i:4388;s:14:"end_line_index";i:706;s:15:"end_token_index";i:4388;}s:14:"breakLongWords";a:20:{s:4:"name";s:14:"breakLongWords";s:16:"start_line_index";i:711;s:17:"start_token_index";i:4392;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:46:"/**
	* breakLongWords: breaks long words
	*/";}s:25:"start_comments_line_index";i:708;s:26:"start_comments_token_index";i:4390;s:23:"end_comments_line_index";i:708;s:24:"end_comments_token_index";i:4390;s:22:"start_args_token_index";i:4399;s:20:"end_args_token_index";i:4415;s:9:"arguments";a:3:{s:7:"$string";N;s:10:"$maxLength";s:2:"20";s:5:"$html";s:5:"false";}s:25:"start_brackets_line_index";i:711;s:26:"start_brackets_token_index";i:4417;s:23:"end_brackets_line_index";i:715;s:24:"end_brackets_token_index";i:4465;s:14:"end_line_index";i:715;s:15:"end_token_index";i:4465;}s:18:"breakLongTextWords";a:20:{s:4:"name";s:18:"breakLongTextWords";s:16:"start_line_index";i:720;s:17:"start_token_index";i:4469;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:55:"/**
	* breakLongTextWords: breaks long text words
	*/";}s:25:"start_comments_line_index";i:717;s:26:"start_comments_token_index";i:4467;s:23:"end_comments_line_index";i:717;s:24:"end_comments_token_index";i:4467;s:22:"start_args_token_index";i:4476;s:20:"end_args_token_index";i:4485;s:9:"arguments";a:2:{s:7:"$string";N;s:10:"$maxLength";s:2:"20";}s:25:"start_brackets_line_index";i:720;s:26:"start_brackets_token_index";i:4487;s:23:"end_brackets_line_index";i:738;s:24:"end_brackets_token_index";i:4631;s:14:"end_line_index";i:738;s:15:"end_token_index";i:4631;}s:18:"breakLongHtmlWords";a:20:{s:4:"name";s:18:"breakLongHtmlWords";s:16:"start_line_index";i:743;s:17:"start_token_index";i:4635;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:55:"/**
	* breakLongHtmlWords: breaks long html words
	*/";}s:25:"start_comments_line_index";i:740;s:26:"start_comments_token_index";i:4633;s:23:"end_comments_line_index";i:740;s:24:"end_comments_token_index";i:4633;s:22:"start_args_token_index";i:4642;s:20:"end_args_token_index";i:4658;s:9:"arguments";a:3:{s:4:"$str";N;s:10:"$maxLength";s:2:"20";s:5:"$char";s:3:"" "";}s:25:"start_brackets_line_index";i:743;s:26:"start_brackets_token_index";i:4659;s:23:"end_brackets_line_index";i:779;s:24:"end_brackets_token_index";i:4902;s:14:"end_line_index";i:779;s:15:"end_token_index";i:4902;}s:14:"sanitizeString";a:20:{s:4:"name";s:14:"sanitizeString";s:16:"start_line_index";i:784;s:17:"start_token_index";i:4906;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:29:"/**
	* sanitizeString: 
	*/";}s:25:"start_comments_line_index";i:781;s:26:"start_comments_token_index";i:4904;s:23:"end_comments_line_index";i:781;s:24:"end_comments_token_index";i:4904;s:22:"start_args_token_index";i:4913;s:20:"end_args_token_index";i:4922;s:9:"arguments";a:2:{s:7:"$string";N;s:5:"$html";s:5:"false";}s:25:"start_brackets_line_index";i:784;s:26:"start_brackets_token_index";i:4924;s:23:"end_brackets_line_index";i:792;s:24:"end_brackets_token_index";i:4983;s:14:"end_line_index";i:792;s:15:"end_token_index";i:4983;}s:12:"sanitizeText";a:20:{s:4:"name";s:12:"sanitizeText";s:16:"start_line_index";i:797;s:17:"start_token_index";i:4987;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:27:"/**
	* sanitizeText: 
	*/";}s:25:"start_comments_line_index";i:794;s:26:"start_comments_token_index";i:4985;s:23:"end_comments_line_index";i:794;s:24:"end_comments_token_index";i:4985;s:22:"start_args_token_index";i:4994;s:20:"end_args_token_index";i:5003;s:9:"arguments";a:2:{s:7:"$string";N;s:5:"$html";s:5:"false";}s:25:"start_brackets_line_index";i:797;s:26:"start_brackets_token_index";i:5005;s:23:"end_brackets_line_index";i:816;s:24:"end_brackets_token_index";i:5178;s:14:"end_line_index";i:816;s:15:"end_token_index";i:5178;}}}}
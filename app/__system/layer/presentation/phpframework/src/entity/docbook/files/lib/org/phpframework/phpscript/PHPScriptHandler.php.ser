a:1:{s:16:"PHPScriptHandler";a:1:{s:7:"methods";a:10:{s:12:"parseContent";a:15:{s:4:"name";s:12:"parseContent";s:16:"start_line_index";i:7;s:17:"start_token_index";i:23;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:30;s:20:"end_args_token_index";i:59;s:9:"arguments";a:4:{s:8:"$content";N;s:15:"&$external_vars";s:7:"array()";s:15:"&$return_values";s:7:"array()";s:28:"$ignore_undefined_vars_error";s:5:"false";}s:25:"start_brackets_line_index";i:7;s:26:"start_brackets_token_index";i:61;s:23:"end_brackets_line_index";i:181;s:24:"end_brackets_token_index";i:1443;s:14:"end_line_index";i:181;s:15:"end_token_index";i:1443;}s:27:"parseContentWithIncludeFile";a:20:{s:4:"name";s:27:"parseContentWithIncludeFile";s:16:"start_line_index";i:185;s:17:"start_token_index";i:1449;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:12:"//Not tested";i:1;s:404:"//The difference between this method and the parseContent method, is that, if there is an error in some php statement of the $content, this method returns an empty result, because the error will be catched with no return string. Instead of the parseContent method, that executes each php statement separately returning the rest of the result and only giving error in the catched php statement with error.";}s:25:"start_comments_line_index";i:183;s:26:"start_comments_token_index";i:1445;s:23:"end_comments_line_index";i:184;s:24:"end_comments_token_index";i:1447;s:22:"start_args_token_index";i:1456;s:20:"end_args_token_index";i:1485;s:9:"arguments";a:4:{s:8:"$content";N;s:15:"&$external_vars";s:7:"array()";s:15:"&$return_values";s:7:"array()";s:28:"$ignore_undefined_vars_error";s:5:"false";}s:25:"start_brackets_line_index";i:185;s:26:"start_brackets_token_index";i:1487;s:23:"end_brackets_line_index";i:205;s:24:"end_brackets_token_index";i:1627;s:14:"end_line_index";i:205;s:15:"end_token_index";i:1627;}s:23:"getIncludedFilePathHtml";a:20:{s:4:"name";s:23:"getIncludedFilePathHtml";s:16:"start_line_index";i:208;s:17:"start_token_index";i:1631;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:12:"//Not tested";}s:25:"start_comments_line_index";i:207;s:26:"start_comments_token_index";i:1629;s:23:"end_comments_line_index";i:207;s:24:"end_comments_token_index";i:1629;s:22:"start_args_token_index";i:1638;s:20:"end_args_token_index";i:1667;s:9:"arguments";a:4:{s:10:"$file_path";N;s:15:"&$external_vars";s:7:"array()";s:15:"&$return_values";s:7:"array()";s:28:"$ignore_undefined_vars_error";s:5:"false";}s:25:"start_brackets_line_index";i:208;s:26:"start_brackets_token_index";i:1669;s:23:"end_brackets_line_index";i:218;s:24:"end_brackets_token_index";i:1718;s:14:"end_line_index";i:218;s:15:"end_token_index";i:1718;}s:15:"includeFilePath";a:20:{s:4:"name";s:15:"includeFilePath";s:16:"start_line_index";i:221;s:17:"start_token_index";i:1722;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:12:"//Not tested";}s:25:"start_comments_line_index";i:220;s:26:"start_comments_token_index";i:1720;s:23:"end_comments_line_index";i:220;s:24:"end_comments_token_index";i:1720;s:22:"start_args_token_index";i:1729;s:20:"end_args_token_index";i:1758;s:9:"arguments";a:4:{s:10:"$file_path";N;s:15:"&$external_vars";s:7:"array()";s:15:"&$return_values";s:7:"array()";s:28:"$ignore_undefined_vars_error";s:5:"false";}s:25:"start_brackets_line_index";i:221;s:26:"start_brackets_token_index";i:1760;s:23:"end_brackets_line_index";i:300;s:24:"end_brackets_token_index";i:2388;s:14:"end_line_index";i:300;s:15:"end_token_index";i:2388;}s:14:"isValidPHPCode";a:20:{s:4:"name";s:14:"isValidPHPCode";s:16:"start_line_index";i:331;s:17:"start_token_index";i:2392;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:1276:"/* 
	   Note that the $code must be a valid php code without being wraped in the PHP TAGS, bc the $code will be executed through the eval.
	   
	   Valid code samples:
	   	$code = "''";
	   	$code = '""';
		$code = '$x[23][\'asd\'][ $x["as"] ]';
		$code = '${x[23][\'asd\'][ $x["as"] ]}';
		$code = '"{$x[23][\'asd\'][ $x[\'as\'] ]}"';
		$code = '"asa" . "as"';
		$code = "'asd'";
		$code = 'Bar::foo("as", 234) . jplpinto() . "{$x[23][\'as\'][$y]}" . foo';
		$code = '"{$x[23][\'as\'][$y]}"';
		$code = '"asa" . $x. "as"';
		$code = '"onClick=\"return openChannelArticles(this, event, \'#url#\', \'#label#\')\""';
		$code = '$asd . "{$asd[\'as\']}" . $d';
		$code = "true";
		$code = 'aasd_as'; //php thinks it is a defined var
		$code = 'ArticleService . insert'; //php thinks "ArticleService" is an defined var with an object and "insert" a method.
		$code = 'ArticleService -> insert'; //php thinks "ArticleService" is an defined var with an object and "insert" a method.
		$code = 'ArticleService :: insert'; //php thinks "ArticleService" is an defined var with an object and "insert" a method.
		
	   Invalid code samples:
	   	$code = "";
		$code = 'aasd as d asd a';
		$code = '#previous_html##label##next_html#';
		$code = 'aasd_{$d}as';
		$code = 'aasd_${d}as';
	*/";}s:25:"start_comments_line_index";i:302;s:26:"start_comments_token_index";i:2390;s:23:"end_comments_line_index";i:302;s:24:"end_comments_token_index";i:2390;s:22:"start_args_token_index";i:2399;s:20:"end_args_token_index";i:2405;s:9:"arguments";a:2:{s:5:"$code";N;s:15:"&$error_message";N;}s:25:"start_brackets_line_index";i:331;s:26:"start_brackets_token_index";i:2407;s:23:"end_brackets_line_index";i:362;s:24:"end_brackets_token_index";i:2634;s:14:"end_line_index";i:362;s:15:"end_token_index";i:2634;}s:18:"isValidPHPContents";a:20:{s:4:"name";s:18:"isValidPHPContents";s:16:"start_line_index";i:365;s:17:"start_token_index";i:2638;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:101:"//Note that this function only check the php syntax. It needs the PhpParser library previous included";}s:25:"start_comments_line_index";i:364;s:26:"start_comments_token_index";i:2636;s:23:"end_comments_line_index";i:364;s:24:"end_comments_token_index";i:2636;s:22:"start_args_token_index";i:2645;s:20:"end_args_token_index";i:2655;s:9:"arguments";a:2:{s:9:"$contents";N;s:7:"&$error";s:4:"null";}s:25:"start_brackets_line_index";i:365;s:26:"start_brackets_token_index";i:2657;s:23:"end_brackets_line_index";i:401;s:24:"end_brackets_token_index";i:2876;s:14:"end_line_index";i:401;s:15:"end_token_index";i:2876;}s:19:"isValidPHPContents2";a:20:{s:4:"name";s:19:"isValidPHPContents2";s:16:"start_line_index";i:404;s:17:"start_token_index";i:2880;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:214:"//The problem with this function is that it will execute the php code and we only wanted to check the php syntax. If we execute the PHP code will give erros bc there will be variables that will not be present here!";}s:25:"start_comments_line_index";i:403;s:26:"start_comments_token_index";i:2878;s:23:"end_comments_line_index";i:403;s:24:"end_comments_token_index";i:2878;s:22:"start_args_token_index";i:2887;s:20:"end_args_token_index";i:2897;s:9:"arguments";a:2:{s:9:"$contents";N;s:7:"&$error";s:4:"null";}s:25:"start_brackets_line_index";i:404;s:26:"start_brackets_token_index";i:2899;s:23:"end_brackets_line_index";i:445;s:24:"end_brackets_token_index";i:3178;s:14:"end_line_index";i:445;s:15:"end_token_index";i:3178;}s:24:"isValidPHPContentsViaUrl";a:20:{s:4:"name";s:24:"isValidPHPContentsViaUrl";s:16:"start_line_index";i:455;s:17:"start_token_index";i:3184;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:433:"/*
	 * Send $code to the url page through curl and check if the answer is == 1. Othewise is not valid.
	 *
	 * The idea is to have a file that calls the isValidPHPContentsViaUrl which will call another file (via URL) which will include the php code and echo "1". The first file will check then the request's response and if it is == 1, the code is valid, otherwise it shows the error.
	 * 
	 * Note: this function is not tested.
	 */";i:1;s:214:"//The problem with this function is that it will execute the php code and we only wanted to check the php syntax. If we execute the PHP code will give erros bc there will be variables that will not be present here!";}s:25:"start_comments_line_index";i:447;s:26:"start_comments_token_index";i:3180;s:23:"end_comments_line_index";i:454;s:24:"end_comments_token_index";i:3182;s:22:"start_args_token_index";i:3191;s:20:"end_args_token_index";i:3211;s:9:"arguments";a:4:{s:4:"$url";N;s:9:"$contents";N;s:7:"&$error";s:4:"null";s:19:"$connection_timeout";s:1:"0";}s:25:"start_brackets_line_index";i:455;s:26:"start_brackets_token_index";i:3213;s:23:"end_brackets_line_index";i:494;s:24:"end_brackets_token_index";i:3605;s:14:"end_line_index";i:494;s:15:"end_token_index";i:3605;}s:32:"isValidPHPContentsViaCommandLine";a:20:{s:4:"name";s:32:"isValidPHPContentsViaCommandLine";s:16:"start_line_index";i:505;s:17:"start_token_index";i:3611;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:889:"/* We strongly DON'T advise the use of this method bc it uses command line, and if a server has the php command line defined differently, this command line won't work, this is, if a server doesn't have the php in the /bin or /usr/bin we cannot simply do "php ...", we must use the full path "/usr/bin/php/". 
	 * Additionally this function doesn't work on windows.
	 * TRY TO AVOID THIS METHOD
	 * Instead you can use the the methods isValidPHPContents or printPHPContentsViaUrl + isValidPHPContentsViaUrl. 
	 * The idea is to have a file that calls the isValidPHPContentsViaUrl which will call another file (via URL) which will include the php code and echo "1". The first file will check then the request's response and if it is == 1, the code is valid, otherwise it shows the error.
	 * 
	 * Additionally note that the shell_exec function should be avoid bc has some security risks
	 */";i:1;s:48:"//$contents must be wrapped in the PHP TAGS (<?)";}s:25:"start_comments_line_index";i:496;s:26:"start_comments_token_index";i:3607;s:23:"end_comments_line_index";i:504;s:24:"end_comments_token_index";i:3609;s:22:"start_args_token_index";i:3618;s:20:"end_args_token_index";i:3628;s:9:"arguments";a:2:{s:9:"$contents";N;s:7:"&$error";s:4:"null";}s:25:"start_brackets_line_index";i:505;s:26:"start_brackets_token_index";i:3630;s:23:"end_brackets_line_index";i:554;s:24:"end_brackets_token_index";i:3928;s:14:"end_line_index";i:554;s:15:"end_token_index";i:3928;}s:22:"printPHPContentsViaUrl";a:19:{s:4:"name";s:22:"printPHPContentsViaUrl";s:16:"start_line_index";i:562;s:17:"start_token_index";i:3932;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:404:"/*
	 * receives $code from POST, create a temp file with it, include file, catch all outputs and at the end returns "1". If echo 1 is the only thing printed, it means the code is correct.
	 * Note: this function should not return anything bc if there is a php syntax error, apache will stop executing the code at the "include" line and echo the php error.
	 * 
	 * Note: this function is not tested.
	 */";}s:25:"start_comments_line_index";i:556;s:26:"start_comments_token_index";i:3930;s:23:"end_comments_line_index";i:556;s:24:"end_comments_token_index";i:3930;s:22:"start_args_token_index";i:3939;s:20:"end_args_token_index";i:3940;s:25:"start_brackets_line_index";i:562;s:26:"start_brackets_token_index";i:3942;s:23:"end_brackets_line_index";i:581;s:24:"end_brackets_token_index";i:4099;s:14:"end_line_index";i:581;s:15:"end_token_index";i:4099;}}}}
<!-- Generated by Rakefile:build -->

<strong>
Gryffyn
</strong>
on 2012-07-08 19:48:34 <br />
A couple people mentioned the .toFixed(precision) but I overlooked them because they didn't mention the specific problem I was having (or at least not with the keywords I was searching the page for).

Basically I wanted to display money values in a way that was consistent with how we usually write money values.

With the round() function as it is today, 1.10 would return 1.1 even with precision of 2.

I ended up not using the rounding function since I didn't need precision, just wanted to truncate after the second decimal but always show two decimals (which wasn't working when it had a zero on the end).

If you're starting with a string, you can either do this:

<pre><code>
var fixed = new Number(somestring);
alert(fixed.toFixed(2));
</code></pre>

Or you can do:
<pre><code>
var fixed = parseFloat(somestring);
alert(fixed.toFixed(2));
</code></pre>

Again, this was mostly mentioned but not in the context of money (dollar, etc) values and trailing zeros.
<hr />


<strong>
<a href="http://codedninja.com" rel="nofollow">Michael Pivonka</a>
</strong>
on 2012-04-04 12:07:20 <br />
<pre><code>
190000000 gives out 189999999.99999997
</code></pre>
and
<pre><code>
200000000 gives out 199999999.99999988
</code></pre>
<hr />


<strong>
max4ever
</strong>
on 2011-10-11 18:14:53 <br />
this one is tiny and works (doesn't support the php_round_... variables though) http://stackoverflow.com/questions/6437062/javascript-vs-php-rounding/6438281#6438281
<hr />


<strong>
Mickey
</strong>
on 2011-03-29 17:53:26 <br />
Just realized that I &quot;killed&quot; the function for integers.

<pre><code>
if(String(value).lastIndexOf(&quot;.&quot;) &lt; 0) {
    value *= m;
} else {
    // my posted code
}
</code></pre>

:)
<hr />


<strong>
Mickey
</strong>
on 2011-03-29 17:36:28 <br />
Hello!

Thank you for this. But... I found some examples where this gives inaccurate results:
<pre><code>
round(162.295, 2); //gives 162.29
round(613.305, 2); //gives 613.3
</code></pre>

The problem is multiplying by power of ten gives:
<pre><code>
162.295 * 100; //gives 16229.499999999998
</code></pre>

There is one more, but the result is OK:

<pre><code>
162.395 * 100; //gives 16239.500000000002
</code></pre>

I changed (line 33):

<pre><code>
value *= m;
</code></pre> 

with this:
<pre><code>
var stringValue = String(value);
var newDecimalPlace = stringValue.lastIndexOf(&quot;.&quot;) + precision;
stringValue = stringValue.replace(&quot;.&quot;, &quot;&quot;);
if (newDecimalPlace &lt; 0) {
	var tempStringValue = &quot;0.&quot;;
	for (var i = newDecimalPlace; i &lt; 0; i++) {
		tempStringValue += &quot;0&quot;;
	}
	value = Number(tempStringValue + stringValue);
} else {
	value = Number(stringValue.substr(0, newDecimalPlace) + &quot;.&quot; + stringValue.substr(newDecimalPlace));
			}
</code></pre>

Basically I multiply by power of 10 by moving the &quot;.&quot; in the number converted to a string. If &quot;precision&quot; is negative - pad the number with &quot;0.&quot; and needed number of zeros, otherwise - place the &quot;.&quot; in new place.

It works for examples I found.

Thanks.
<hr />


<strong>
<a href="http://www.ws3.es" rel="nofollow">Josep Sanz</a>
</strong>
on 2010-09-10 16:15:40 <br />
I update the php.js library to the lastest version and the round function work as expected.

Thanks Rafał Kukawski.

Josep.
<hr />


<strong>
<a href="http://kevin.vanzonneveld.net" rel="nofollow">Kevin van Zonneveld</a>
</strong>
on 2010-09-08 19:41:46 <br />
@ Josep Sanz: Rafał Kukawski has fixed your issue!

@ Rafał Kukawski: Thanks, this one is much better. All current tests (found in the example comment blocks) pass!
https://github.com/kvz/phpjs/commit/9d563a56bcc28c290a6148ffcbd37e3052cee523

PS
If you'd like commit access to our github repository, drop me a line kvz@php.net
<hr />


<strong>
<a href="http://blog.kukawski.pl" rel="nofollow">Rafa? Kukawski</a>
</strong>
on 2010-09-04 10:11:14 <br />
BTW. while doing basic tests I compared the results with PHP 5.3.1.
<hr />


<strong>
<a href="http://blog.kukawski.pl" rel="nofollow">Rafa? Kukawski</a>
</strong>
on 2010-09-04 10:06:51 <br />
Didn't test it much, but this is my implementation of the function.

<pre><code>function round(value, precision, mode){
	var m, f, isHalf, sgn; // helper variables
	precision |= 0; // making sure precision is integer
	m = Math.pow(10, precision);
	value *= m;
	sgn = (value&gt;0)|-(value&lt;0); // sign of the number
	isHalf = value % 1 === 0.5 * sgn;
	f = Math.floor(value);
	
	if(isHalf){
		switch(mode){
			case 'PHP_ROUND_HALF_DOWN':
				value = f + (sgn &lt; 0); // rounds .5 toward zero
				break;
			case 'PHP_ROUND_HALF_EVEN':
				value = f + (f % 2 * sgn); // rouds .5 towards the next even integer
				break;
			case 'PHP_ROUND_HALF_ODD':
				value = f + !(f % 2); // rounds .5 towards the next odd integer
				break;
			default:
				value = f + (sgn &gt; 0); // rounds .5 away from zero
		}
	}
	
	return (isHalf ? value : Math.round(value)) / m;
}</code></pre>

I'll try to prepare some unit tests today and test this function.
<hr />


<strong>
<a href="http://www.ws3.es" rel="nofollow">Josep Sanz</a>
</strong>
on 2010-09-02 12:22:23 <br />
Hi PHPJS team.

I detect an error:
<pre><code>
round(58551.799999999996,2) 
returns 58551.799999999996
</code></pre>

If I change the precision to 1 or 3, work as expected

Thanks.
<hr />


<strong>
<a href="http://brett-zamir.me" rel="nofollow">Brett Zamir</a>
</strong>
on 2010-04-20 11:20:10 <br />
@gaurav: Please try with the latest version at http://github.com/kvz/phpjs/raw/master/functions/math/round.js and see if that works as we made a fix here recently...
<hr />


<strong>
gaurav
</strong>
on 2010-04-20 07:51:44 <br />
this function rounds &quot;1236.0000000000002&quot; to 123.12.

how shall I solve this problem.
<hr />


<strong>
<a href="http://brett-zamir.me" rel="nofollow">Brett Zamir</a>
</strong>
on 2010-04-03 08:03:54 <br />
@William: What's missing is a digit, and I don't mean a finger or a toe... The code had problems when the first digit was 0 or when the number to be rounded up was 9, now fixed in Git; see http://github.com/kvz/phpjs/raw/master/functions/math/round.js . Nice test, btw... and thanks! :)
<hr />


<strong>
William
</strong>
on 2010-04-02 21:13:31 <br />
round(179.06) = 17?

What am I missing here?

<pre><code>
while (mynum &lt; 300)
{
	mynum += Math.random();
	if (round(mynum) != Math.round(mynum))
		document.getElementsByTagName('body')[0].innerHTML += '&lt;br&gt;'+mynum+' '+round(mynum)+' '+Math.round(mynum);
}
</code></pre>
<hr />


<strong>
<a href="http://brett-zamir.me" rel="nofollow">Brett Zamir</a>
</strong>
on 2010-01-09 13:43:33 <br />
@kadimi: Thank you for offering your shorter version. Since we're offering the full PHP API (with all three arguments), more was necessary... If you can reimplement in a shorter form than ours and still fully support all 3 arguments (without adding processing), we'd be all for it...In any case, maybe your version will be of interest to others who don't care about the full API...
<hr />


<strong>
<a href="http://www.kadimi.com/en/webdesign/javascript/round-float/" rel="nofollow">kadimi</a>
</strong>
on 2010-01-09 10:19:43 <br />
My tiny version... lol
<pre><code>
function round_float(x,n){
  if(arguments.length &lt; 2 || !parseInt(n))
  	var n=0;
  if(!parseFloat(x))
  	return false;
  return Math.round(x*Math.pow(10,n))/Math.pow(10,n);
}
</code></pre>
<hr />


<strong>
<a href="http://kevin.vanzonneveld.net" rel="nofollow">Kevin van Zonneveld</a>
</strong>
on 2009-12-14 16:19:15 <br />
@ meo: I've added testcases to confirm your issue:
http://github.com/kvz/phpjs/commit/c8dda288ef6f4e1a5c803c7e7338e460a6ca006e

Try with 
<pre><code>
1.1749999999999 // 13 digits
</code></pre>
and php still gives the correct
<pre><code>
1.17
</code></pre>

Try with 
<pre><code>
1.17499999999999 // 14 digits
</code></pre>
and php gives the 'incorrect'
<pre><code>
1.18
</code></pre>

Both on my 32 bits as my 64 bits system, PHP messes it up and turns the last number into 1.18.

So it looks like PHP is simplifying the number as it gets 14 decimal digits. I checked here http://php.net/manual/en/language.types.float.php and my suspicion was confirmed: &quot;The size of a float is platform-dependent, although a maximum of ~1.8e308 with a precision of roughly 14 decimal digits is a common value (the 64 bit IEEE format).&quot;

So even though this is a gray array, we may need to consider to break round on purpose, just to make it complient with PHP.

Thoughts?
<hr />


<strong>
meo
</strong>
on 2009-11-09 12:32:41 <br />
Correction! For on step rounding like before it works, but for the following.

<pre><code>
round(1.1749999999999998, 2);
</code></pre>

returns 1.18  on php and 1.17 on JavaScript. Sorry about the previous post.
<hr />


<strong>
meo
</strong>
on 2009-11-09 10:24:55 <br />
when I round: 

<pre><code>
round(0.175, 2); 
</code></pre>

I get 0.17 instead of 0.18 in php round, what could be wrong?
<hr />


<strong>
meo
</strong>
on 2009-11-09 10:20:28 <br />
when I round round(0.175, 2); I get 0.17 instead of 0.178 in php round, what could be wrong?
<hr />


<strong>
<a href="http://kevin.vanzonneveld.net" rel="nofollow">Kevin van Zonneveld</a>
</strong>
on 2009-08-04 11:35:08 <br />
@ T.Wild: Great job! 
(for the record: I like http://phpjs.org/functions/pathinfo:486 's way of handling constant arguments best)
<hr />


<strong>
<a href="http://brett-zamir.me" rel="nofollow">Brett Zamir</a>
</strong>
on 2009-07-29 02:39:38 <br />
@T. Wild: I've added your changes, with some whitespace clean-up, capitalization changes (initial-capitalized generally represent constructors, while full-capitalized generally represent constants), and removed the comment about the constant values being unknown, since you had the correct numeric values per the PHP source
@Kevin: It looks ready to be applied the next time we update.
<hr />


<strong>
T.Wild
</strong>
on 2009-07-28 20:13:23 <br />
O.K, re-written version of my round function,  I really should learn how to test better and actually double check returned values :) anyway, this version appears to work and implements round half up, half down, half even and half odd.

I removed ceiling, floor, up and down since their not mentioned in the PHP manual.

any further suggestions are welcome.

<pre><code>
function round (val, precision, mode) {
    // http://kevin.vanzonneveld.net
    // +   original by: Philip Peterson
    // +    revised by: Onno Marsman
    // +      input by: Greenseed
    // +    revised by: T.Wild
    // %        note 1: Great work. Ideas for improvement:
    // %        note 1:  - code more compliant with developer guidelines
    // %        note 1:  - for implementing PHP constant arguments look at
    // %        note 1:  the pathinfo() function, it offers the greatest
    // %        note 1:  flexibility &amp; compatibility possible
    // *     example 1: round(1241757, -3);
    // *     returns 1: 1242000
    // *     example 2: round(3.6);
    // *     returns 2: 4
    // *     example 3: round(2.835,2);
    // *     returns 3: 2.84

    /*Declare Variables
     * Retval  - temporay holder of the value to be returned
     * V       - String representation of val
     * integer - Integer portion of val
     * decimal - decimal portion of val
     * decp    - characterindex of . [decimal point] inV
     * negative- was val a negative value?
     *
     * ROUND_HALF_OE - Rounding function for ROUND_HALF_ODD and ROUND_HALF_EVEN
     * ROUND_HALF_UD - Rounding function for ROUND_HALF_UP and ROUND_HALF_DOWN
     * ROUND_HALF    - Primary function for round half rounding modes
     */
    var RetVal=0,V='',integer='',decimal='',decp=0,negative=false;
    var ROUND_HALF_OE = function(DtR,DtLa,even){
        if(even === true){
            if(DtLa == 50){
                if((DtR % 2) === 1){
                    if(DtLa &gt;= 5){
                        DtR+=1;
                    }else{
                        DtR-=1;
                    }
                }
            }else if(DtLa &gt;= 5){
                DtR+=1;
            }
        }else{
            if(DtLa == 5){
                if((DtR % 2) === 0){
                    if(DtLa &gt;= 5){
                        DtR+=1;
                    }else{
                        DtR-=1;
                    }
                }
            }else if(DtLa &gt;= 5){
                DtR+=1;
            }
        }
        return DtR;
    };
    var ROUND_HALF_UD = function(DtR,DtLa,up){
        if(up === true){
            if(DtLa&gt;=5){
                DtR+=1;
            }
        }else{
            if(DtLa&gt;5){
                DtR+=1;
            }
        }
        return DtR;
    };
    var ROUND_HALF = function(Val,Decplaces,mode){
        /*Declare variables
         *V       - string representation of Val
         *Vlen    - The length of V - used only when rounding intgerers
         *VlenDif - The difference between the lengths of the original V
         *          and the V after being truncated
         *decp    - character in index of . [decimal place] in V
         *integer - Integr protion of Val
         *decimal - Decimal portion of Val
         *DigitToRound - The digit to round
         *DigitToLookAt- The digit to comapre when rounding
         *
         *round - A function to do the rounding
         */
        var V = Val.toString(),Vlen=0,VlenDif=0;
        var decp = V.indexOf('.');
        var DigitToRound = 0,DigitToLookAt = 0;
        var integer='',decimal='';
        var round = null,bool=false;
        switch(mode){
            case 'up':
                bool = true;
            case 'down':
                round = ROUND_HALF_UD;
                break;
            case 'even':
                bool = true;
            case 'odd':
                round = ROUND_HALF_OE;
                break;
        }
        if (Decplaces &lt; 0){ //Int round
            Vlen=V.length;
            Decplaces = Vlen + Decplaces;
            DigitToLookAt = Number(V.charAt(Decplaces));
            DigitToRound  = Number(V.charAt(Decplaces-1));
            DigitToRound  = round(DigitToRound,DigitToLookAt,bool);
            V = V.slice(0,Decplaces-1);
            VlenDif = Vlen-V.length-1;
            if (DigitToRound == 10){
                V = String(Number(V)+1)+&quot;0&quot;;
            }else{
                V+=DigitToRound;
            }
            V = Number(V)*(Math.pow(10,VlenDif));
        }else if(Decplaces &gt; 0){
            integer=V.slice(0,decp);
            decimal=V.slice(decp+1);
            DigitToLookAt = Number(decimal.charAt(Decplaces));
            DigitToRound  = Number(decimal.charAt(Decplaces-1));
            DigitToRound  = round(DigitToRound,DigitToLookAt,bool);
            decimal=decimal.slice(0,Decplaces-1);
            if(DigitToRound==10){
                V=Number(integer+'.'+decimal)+(1*(Math.pow(10,(0-decimal.length))));
            }else{
                V=Number(integer+'.'+decimal+DigitToRound);
            }
        }else{
            integer=V.slice(0,decp);
            decimal=V.slice(decp+1);
            DigitToLookAt = Number(decimal.charAt(Decplaces));
            DigitToRound  = Number(integer.charAt(integer.length-1));
            DigitToRound  = round(DigitToRound,DigitToLookAt,bool);
            decimal='0';
            integer = integer.slice(0,integer.length-1);
            if(DigitToRound==10){
                V=Number(integer)+1;
            }else{
                V=Number(integer+DigitToRound);
            }
        }
        return V;
    };

    //precision optional - defaults 0
    if (typeof precision == 'undefined') {
        precision = 0;
    }
    //mode optional - defaults round half up
    if (typeof mode == 'undefined') {
        mode = 'PHP_ROUND_HALF_UP';
    }

    if (val &lt; 0){ //Remember if val is negative
        negative = true;
    }else{
        negative = false;
    }

    V = Math.abs(val).toString(); //Take a string representation of val
    decp = V.indexOf('.');        //And locate the decimal point
    if ((decp == -1) &amp;&amp; (precision &gt;=0)){
        /* If there is no deciaml point and the precision is greater than 0
         * there is no need to round, return val
         */
        return val;
    }else{
        if (decp == -1){
            //There are no decimals so intger=V and decimal=0
            integer = V;
            decimal = '0';
        }else{
            //Otherwise we have to split the decimals from the integer
            integer = V.slice(0,decp);
            if(precision &gt;= 0){
                //If the precision is greater than 0 then split the decimals from the integer
                //We truncate the decimals to a number of places equal to the precision requested+1
                decimal = V.substr(decp+1,precision+1);
            }else{
                //If the precision is less than 0 ignore the decimals - set to 0
                decimal = '0';
            }
        }
        if ((precision &gt; 0) &amp;&amp; (precision &gt;= decimal.length)){
            /*If the precision requested is more decimal places than already exist
             *there is no need to round - return val
             */
            return val;
        }else if ((precision &lt; 0) &amp;&amp; (Math.abs(precision) &gt;= integer.length)){
            /*If the precison is less than 0, and is greater than than the
             *number of digits in integer, return 0 - mimics PHP
             */
            return 0;
        }
        val = Number(integer+'.'+decimal); //After sanitizing recreate val,
    }

    //Call approriate function based on passed mode, fall through for integer constants
    //INTEGER VALUES MAY NOT BE CORRECT, UNABLE TO VERIFY WITHOUT PHP 5.3//
    switch (mode){
        case 0:
        case 'PHP_ROUND_HALF_UP':
            RetVal = ROUND_HALF(val,precision,'up');
            break;
        case 1:
        case 'PHP_ROUND_HALF_DOWN':
            RetVal = ROUND_HALF(val, precision,'down');
            break;
        case 2:
        case 'PHP_ROUND_HALF_EVEN':
            RetVal = ROUND_HALF(val,precision,'even');
            break;
        case 3:
        case 'PHP_ROUND_HALF_ODD':
            RetVal = ROUND_HALF(val,precision,'odd');
            break;
    }
    if(negative){
        return 0-RetVal;
    }else{
        return RetVal;
    }
}
<pre><code>
<hr />


<strong>
<a href="http://kevin.vanzonneveld.net" rel="nofollow">Kevin van Zonneveld</a>
</strong>
on 2009-07-14 12:39:04 <br />
ohyeah: 
@ Greenseed: Thanks for helping us out!

@ T. Wild: PS, you can have a look at the source here:
http://trac.plutonia.nl/projects/phpjs/browser/trunk/functions/math/round.js
I'll actually deploy it to the site when all test-cases pass.
<hr />


<strong>
<a href="http://kevin.vanzonneveld.net" rel="nofollow">Kevin van Zonneveld</a>
</strong>
on 2009-07-14 12:37:24 <br />
@ T.Wild: Thanks a lot for really going out of your way to make this solid! I added Greenseed's testcase and it passes. The first function example currently fails though, you may want to look at that if you feel like it. Other than that: Great stuff T. Wild! Awesome.
<hr />


<strong>
T.Wild
</strong>
on 2009-07-12 01:26:20 <br />
A slight oversight on my part,
you'll need to add
if(typeof precision == 'undefined'){precision = 0;}
to the line before
decp = V.indexOf('.');
to account for a precision not being past to the function.
<hr />


<strong>
T.Wild
</strong>
on 2009-07-12 01:15:54 <br />
A round implementation with support for:
PHP_ROUND_UP, PHP_ROUND_DOWN, PHP_ROUND_HALF_UP, PHP_ROUND_HALF_DOWN, PHP_ROUND_FLOOR, PHP_ROUND_CEILING
using http://publib.boulder.ibm.com/infocenter/wmbhelp/v6r0m0/index.jsp?topic=/com.ibm.etools.mft.doc/ak05380_.htm as reference,

It's not pretty but as far as I can tell it works, passes the tests I've thrown at it anyway :)
**can't fully test, don't have PHP 5.3 yet**

The only reason I haven't implemented PHP_ROUND_HALF_EVEN is the example I have to work on only uses 1 dp with a precision of 0, so I don't know what it's meant to do if there are multiple dps.

<pre><code>
function round( val, precision, mode ) {
    var V = val.toString(),integer,decimal,reint = false,decp,d1,d2,pow=0; //Define variables.
    decp = V.indexOf('.'); //Find index of decimal place
    if (decp == -1){ //If there is no decimal place we are most likely dealing with an integer
        /*---ROUNDING AN INTEGER---
         * If the precision is 0 then we don't need to round
         * otherwise turn the integer into a decimal E.G
         * 100 becomes 0.1
         * 2143 becomes 0.2143
         * take the modulus of the precision and then round the decimal
         * we turn it back into an intgeger at the end
         */
        if (precision === 0){
            return val;
        }else{
            pow = V.length; //Rember how many powers of ten we need to turn the decimal back to an integer
            V = '0.'+V;
            precision = Math.abs(precision);
            reint = true; //Remeber to change it back
            decp = 1;
        }
    }else if(precision &lt; 0){
        /*
         * Deling with decimal already, but still want to round an intgeger
         * So truncate V and then do the same as above.
         */
        integer = V.slice(0,decp);
        pow = integer.length;
        V = '0.'+integer;
        precision = Math.abs(precision);
        reint = true;
        decp = 1;
    }

    /*
     * Split the integer and decimal parts of the number
     */
    integer = V.slice(0,decp);
    decimal = V.slice(decp+1);

    /** d1 = decimal before the subject decimal **/

    if (decimal.length &lt;= precision){
        //If the precision is less or equal to the number of decimals then we don't need to round
        return val;
    }else if(precision === 0){
        /**
         * Special handling of precision = 0
         * In this case the number before the subject decimal is the last digit of integer
         * not part of the `decimal` variable
         */
        d1 = Number(integer.charAt(integer.length-1));
        integer = integer.slice(0,integer.length-1);//Remove the last digit of integer
    }else{
        d1 = Number(decimal.charAt(precision-1));
    }

    /** d2 = the subject decimal **/
    d2 = Number(decimal.charAt(precision));
    decimal = decimal.slice(0,precision-1); //remove last digit of decimal

    if (mode=='ROUND_CEILING'){
        if (val &gt; 0){
            mode = 'PHP_ROUND_UP';
        }else{
            mode = 'PHP_ROUND_DOWN';
        }
    }else if(mode=='ROUND_FLOOR'){
        if (val &gt; 0){
            mode = 'PHP_ROUND_DOWN';
        }else{
            mode = 'PHP_ROUND_UP';
        }
    }

    switch (mode){
        case 'PHP_ROUND_UP': //Always round up
                d1+=1;
            break;
        case 'PHP_ROUND_HALF_DOWN': //If subject decimal is more than 5 then round up
            if (d2 &gt; 5){
                d1+=1;
            }
            break;
        default: //If the subject decimal is 5 or more, then round up
            //ROUND_HALF_UP
            if (d2 &gt;= 5){
                d1+=1;
            }
            break;
    }

    if(precision === 0){
        /*
         * Again, special handling for precision 0
         * if the round has made a value of 10, then add 1 to the integer and set d1 to 0
         * this works because of the way I concatinate them
         */
        if (d1 == 10){
            integer+=1;
            d1 = '0';
        }
        val=Number(integer+d1);
    }else{
        if (d1 == 10){
            /*
             * intger = 1
             * decimal = 0.555
             * Number(integr+'.'+decimal) = 1.555
             * (0-decimal.length) = -3
             * 1*(10^-3) = 0.001
             * Number(integr+'.'+decimal)+0.001 = 1.556
             */
            val = Number(integer+'.'+decimal)+(1*(Math.pow(10,(0-decimal.length))));
        }else{
            /*
             * otherwsie just re-concatinate the numbers
             */
            val = Number(integer+'.'+decimal+d1);
        }
    }

    if (reint){
        return val*Math.pow(10,pow);
    }else{
        return val;
    }
}
</code></pre>
<hr />


<strong>
T.Wild
</strong>
on 2009-07-11 20:58:29 <br />
GreenSeed is right, And a test of all 3 digit decimals between 0 and 1 match the PHP value,
A (working) fixed version, not messing with the prototypes:

<pre><code>
function round ( val, precision, mode ) {
    // Returns the number rounded to specified precision
    //
    // version: 904.2314
    // discuss at: http://phpjs.org/functions/round
    // +   original by: Philip Peterson
    // +    revised by: Onno Marsman
    // *     example 1: round(1241757, -3);
    // *     returns 1: 1242000
    // *     example 2: round(3.6);
    // *     returns 2: 4
    // Need to support mode flags: PHP_ROUND_HALF_UP, PHP_ROUND_HALF_DOWN, PHP_ROUND_HALF_EVEN, or PHP_ROUND_HALF_ODD

    precision2 = Math.pow(10,precision);
    return Math.round(val*precision2)/precision2;
}
</code></pre>
<hr />


<strong>
<a href="http://www.aleajecta.com" rel="nofollow">Greenseed</a>
</strong>
on 2009-07-11 05:24:56 <br />
Sorry for last code, was showing what i meaned but wrong :)

here is the working and tested solution.

<pre><code>
Number.prototype.round = function(precision)
{
    precision2 = Math.pow(10,precision);
    return Math.round(this*precision2)/precision2;
};
</code></pre>

But see this page , into the very bottom , about JS way of storing number
<hr />


<strong>
<a href="http://www.aleajecta.com" rel="nofollow">Greenseed</a>
</strong>
on 2009-07-11 04:29:07 <br />
The round funtion will not gave same answer as Php.

PHP:
round(2.835,2) == 2.84

PHP.JS
round(2.835,2) == 2.83

Code i had to add for making it correctely
<pre><code>
Number.prototype.round = function(precision) 
{
    var diff = this - this.toFixed(precision);
    return parseFloat( (this+diff).toFixed(precision) );
}
</code></pre>
I did not test it very much , but with the value i show seem to work better , so see this as a proof of concept
<hr />


<strong>
<a href="http://kevin.vanzonneveld.net" rel="nofollow">Kevin van Zonneveld</a>
</strong>
on 2008-09-24 09:37:13 <br />
@ Onno Marsman: works just fine, I've revised it. Muchos! ;)
<hr />


<strong>
Onno Marsman
</strong>
on 2008-09-23 17:25:03 <br />
Better than my previous suggestion:

<pre><code>
function round (val, precision) {
    return parseFloat(parseFloat(val).toFixed(precision));
}
</code></pre>
<hr />


<strong>
Onno Marsman
</strong>
on 2008-09-22 15:44:54 <br />
How about the following?

<pre><code>
function round (val, precision) {
    return parseFloat(val).toFixed(precision);
}
</code></pre>

I've checked for a call without precision, it also works fine.
<hr />


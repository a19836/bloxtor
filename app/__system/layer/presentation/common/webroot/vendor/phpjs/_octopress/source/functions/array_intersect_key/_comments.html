<!-- Generated by Rakefile:build -->

<strong>
TeMc
</strong>
on 2012-04-06 21:31:15 <br />
@Jean Marie:

1) Maybe it should be limited to arrays, like PHP does

2) No, because the purpose of this website is to re-create php functions in javascript. Feature requests are not accepted here by design.
<hr />


<strong>
<a href="http://brett-zamir.me" rel="nofollow">Brett Zamir</a>
</strong>
on 2009-08-11 19:43:20 <br />
Sorry again, but my reply is mistaken as well. And it will all really depend on whether you are trying to build a return array which returns all of the keys shared across arrays based on the first one, and those subkeys which are shared as well, or if you want to ensure that those whose keys match across all arrays must also, if they are objects, have subkeys which are also contained across all arrays (or otherwise not include them)...
<hr />


<strong>
<a href="http://brett-zamir.me" rel="nofollow">Brett Zamir</a>
</strong>
on 2009-08-11 19:23:18 <br />
Sorry, I realized the long 'if' should be changed to this to account for null values:

<pre><code>if (i === arguments.length-1 &amp;&amp; (typeof arr1[k1] !== 'object' || typeof arr1[k1] === null || ct(arr[k]) === ct(  this.array_intersect_key_recursive.apply(this, tempArr)))) {</code></pre>
<hr />


<strong>
<a href="http://brett-zamir.me" rel="nofollow">Brett Zamir</a>
</strong>
on 2009-08-11 19:04:33 <br />
@Jean Marie: Glad to hear it fit your needs... Since there is otherwise no reasonable way for us to represent associative arrays in JavaScript, the PHP.JS project generally considers objects to be as arrays. As far as your question, I am guessing you want to ensure that only those keys are returned where there is a perfect match, including any subkeys? Here is a recursive version that seems to work for this:

<pre><code>var_dump(
    array_intersect_key_recursive({a:3, b:{c:5, d:5}, q:{r:5}}, {a:'z', c:'y', b:{c:6, d:8}, q:{s:5}})
);

function array_intersect_key_recursive () {
    var arr1 = arguments[0], retArr = {};
    var k1 = '', arr = {}, i = 0, k = '';
    var ct = function (obj) {
        var c = 0;
        for (var p in obj) {
            c++;
        }
        return c;
    };
    arr1keys:
    for (k1 in arr1) {
        var tempArr = [arr1[k1]];
        arrs:
        for (i=1; i &lt; arguments.length; i++) {
            arr = arguments[i];
            for (k in arr) {
                if (k === k1) {
                    tempArr.push(arr[k]);
                    if (i === arguments.length-1 &amp;&amp; (typeof arr1[k1] !== 'object' || ct(arr[k]) === ct(  this.array_intersect_key_recursive.apply(this, tempArr)))) {
                        retArr[k1] = arr1[k1];
                    }
                    // If the innermost loop always leads at least once to an equal value, continue the loop until done
                    continue arrs;
                }
            }
            // If it reaches here, it wasn't found in at least one array, so try next value
            continue arr1keys;
        }
    }
    return retArr;
}</code></pre>
<hr />


<strong>
Jean Marie
</strong>
on 2009-08-11 11:28:37 <br />
Hi,

nice function i was looking for. Thanks!

Two points to mention:
1) You're not handling arrays! It should be named object_intersect_key(). 

2) Is it possible to get this working in recursive.


Best regards
Jean Marie
<hr />


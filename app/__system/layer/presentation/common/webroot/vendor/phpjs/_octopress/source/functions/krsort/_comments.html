<!-- Generated by Rakefile:build -->

<strong>
<a href="http://an3m1.com/" rel="nofollow">????? ?????? ? ?????</a>
</strong>
on 2012-04-11 15:44:49 <br />
I wonder how you got so good. HaHa ! This is really a fascinating blog, lots of stuff that I can get into. One thing I just want to say is that your design is so perfect ! You certainly know how to get a girls attention ! I’m glad that you’re here. I feel like I’ve learned something new by being here
<hr />


<strong>
<a href="http://bahai-library.com" rel="nofollow">Brett Zamir</a>
</strong>
on 2009-01-18 03:44:43 <br />
As for the output buffering issue ideally having a global too, would the following be part of your compiler or dependency idea?

Just specify code like this with each relevant function:

<pre><code>if (!window.php_js) {
    window.php_js = {};
}
if (!window.php_js.output_buffer) {
    window.php_js.output_buffer = document.createDocumentFragment();
}</code></pre>

or

<pre><code>if (!window.php_js) {
    window.php_js = {};
}
if (!window.php_js.sort_helper1) {
    window.php_js.sort_helper1 = function () {
         ...
    }
}</code></pre>

The above could be inside or outside the functions. Outside would be easier to ignore and avoid repeated execution, but inside might be more user friendly and would only increase space if the user didn't realize they could omit it in repeat cases, but should barely affect execution time, since the functions would only be declared once.

I think we do need something like this (whatever option you like) because it would just get out of hand for memory and execution to include these fully and without conditionality within each function.
<hr />


<strong>
<a href="http://kevin.vanzonneveld.net" rel="nofollow">Kevin van Zonneveld</a>
</strong>
on 2009-01-17 15:03:07 <br />
Considering the last story about duplication... I'm struggling with the same problem trying to include the BCMath functions 
http://svn.plutonia.nl/projects/phpjs/browser/trunk/_unported/bc

Which were donated in my mail by a guy named Lance. They all require a shared bc library with 10 functions or something. 

There is no global required include in PHP.JS that would be the obvious place for these shared functions. And I'm still convinced that this library should go without such a requirement.

Still this will mean, either:
OR
- awfully big standalone functions, extreme duplication
- a compiler that defeats duplication. from a developer's perspective, at least.
- a core include with shared functions that is required as a dependency
- make use of the existing dependency system. that would mean adding non-existent-php functions as if they were real php functions and adding them as dependencies. We could store them in a category: phpjssupport. But that would require creating exceptions throughout the project, e.g.: 'SKIP phpjssupport dir when downloading manuals!'
- no bcmath functions at all

It's an imperfect world.
<hr />


<strong>
<a href="http://kevin.vanzonneveld.net" rel="nofollow">Kevin van Zonneveld</a>
</strong>
on 2009-01-17 14:00:30 <br />
@ Brett Zamir: Again: great work.

It's a shame we don't have a php.core.js in which we could just have an array_sorter() with some arguments to diversify in ksort krsort asort arsort, etc.

Same goes for all the intersect &amp;amp; diff functions that only differ a couple of characters. More (maintenance) work for us due to duplication.

But on the other hand: I think it's worth it because we can uphold the philosophy of a lot of independent components that can just be used as is. I bet the majority of PHP.JS  users just copy the functions they need and be on their way.

We could work on a compiler-like feature that just generates all the different sorters based on one template we maintain. But concidering we're only talking about 20 functions or so: that's maybe more work than just distributing changes by hand (copy&amp;amp;paste). Thanks Brett. You're a real PHP.JS pitbull :)
<hr />


<strong>
<a href="http://bahai-library.com" rel="nofollow">Brett Zamir</a>
</strong>
on 2009-01-17 06:40:16 <br />
And here are krsort() and ksort() with the new more readily extensible infrastructure (and speeded krsort()):

<pre><code>function krsort(array, sort_flags) {
    // http://kevin.vanzonneveld.net
    // +   original by: GeekFG (http://geekfg.blogspot.com)
    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // +   improved by: Brett Zamir
    // %          note: The examples are correct, this is a new way
    // *     example 1: data = {2: 'van', 3: 'Zonneveld', 1: 'Kevin'};
    // *     example 1: krsort(data);
    // *     results 1: data == {3: 'Kevin', 2: 'van', 1: 'Zonneveld'}
    // *     returns 1: true
 
    var tmp_arr={}, keys=[], sorter, i, key;
 
	switch (sort_flags) {
		case 'SORT_STRING': // compare items as strings
		case 'SORT_LOCALE_STRING': // compare items as strings, based on the current locale (set with  i18n_loc_set_default() as of PHP6)
			throw 'Not implemented yet';
		case 'SORT_NUMERIC': // compare items numerically
			sorter = function (a, b) {
				return(b - a);
			};
			break;
		case 'SORT_REGULAR': // compare items normally (don't change types)
		default:
			sorter = function (a, b) {
				if (a &amp;lt; b)
					return 1;
				if (a &amp;gt; b)
					return -1;
				return 0;
			};
			break;
	}
 
    // Make a list of key names
    for (key in array) {
        keys.push(key);
    }
 
    keys.sort(sorter);
 
    // Rebuild array with sorted key names
    for (i = 0; i &amp;lt; keys.length; i++) {
        key = keys[i];
        tmp_arr[key] = array[key];
        delete array[key];
    }
    for (i in tmp_arr) {
        array[i] = tmp_arr[i]
    }
 
    return true;
}

 function ksort(array, sort_flags) {
    // http://kevin.vanzonneveld.net
    // +   original by: GeekFG (http://geekfg.blogspot.com)
    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // +   improved by: Brett Zamir
    // %          note: The examples are correct, this is a new way
    // *     example 1: data = {2: 'van', 3: 'Zonneveld', 1: 'Kevin'};
    // *     example 1: ksort(data);
    // *     results 1: data == {1: 'Kevin', 2: 'van', 3: 'Zonneveld'}
    // *     returns 1: true
 
    var tmp_arr={}, keys=[], sorter, i, key;
 
	switch (sort_flags) {
		case 'SORT_STRING': // compare items as strings
		case 'SORT_LOCALE_STRING': // compare items as strings, based on the current locale (set with  i18n_loc_set_default() as of PHP6)
			throw 'Not implemented yet';
		case 'SORT_NUMERIC': // compare items numerically
			sorter = function (a, b) {
				return(a - b);
			};
			break;
		case 'SORT_REGULAR': // compare items normally (don't change types)
		default:
			sorter = function (a, b) {
				if (a &amp;gt; b)
					return 1;
				if (a &amp;lt; b)
					return -1;
				return 0;
			};
			break;
	}
 
    // Make a list of key names
    for (key in array) {
        keys.push(key);
    }
 
    keys.sort(sorter);
 
    // Rebuild array with sorted key names
    for (i = 0; i &amp;lt; keys.length; i++) {
        key = keys[i];
        tmp_arr[key] = array[key];
        delete array[key];
    }
    for (i in tmp_arr) {
        array[i] = tmp_arr[i]
    }
 
    return true;
}</code></pre>
<hr />


<strong>
<a href="http://kevin.vanzonneveld.net" rel="nofollow">Kevin van Zonneveld</a>
</strong>
on 2008-12-01 08:35:21 <br />
@ Chris Wade: Did you also test it with associative arrays (js objects)?
<hr />


<strong>
Chris Wade
</strong>
on 2008-11-25 22:24:14 <br />
I found that init'ing tmp_arr to {} was problematic and changed it to var tmp_arr = [].

Specifically I was unable to get the length of the object... this change doesn't seem to have harmed the function at all.

Also it may stray from the PHP manual a bit but I found it more useful to return the array than to return true, because the original array wasn't being overwritten in my case.  I'm using server-side JScript with Classic ASP.
<hr />

